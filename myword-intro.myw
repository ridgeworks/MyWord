[MyWordDocStyle]
#    MyWord Markup Language

TOC> **Contents**

A markup language enables authors to use annotations to *label* elements of text with their intended meaning. In MyWord documents the authors are free to choose their own *notations* to label text elements with their own meanings.

MyWord documents do not depend on an external markup language specification to define the meaning of a notation. Different authors with different topics can select and evolve their own markup notations.

Here is an example of MyWord markup where the `##` symbol is used to label a header, and the `*` symbol is used as a quote mark notation for italics:

demo
	###  A Header Line

	The *Alice In Wonderland* story.

On the left is the plain text source using MyWord markup, and on the right is an HTML presentation generated from the MyWord markup. The plain text source can be edited with any text editor, and the translation of the markup into an HTML presentation can performed in any modern web-browser.

The MyWord author can define any number of different notations. For example here is a different header label, and a bracket notation for the citation:

sect
	demo
		==  A Header Line

		The *<Alice In Wonderland>* story.
	&
		== ..    <-  <h2 style='margin:0; color:blue; font-style:italic; border-bottom:thin solid blue'>
		*< .. >*  <-  <cite style='color:firebrick'>

&
	sect ..  <-  <div class=sect> myword

Symbolic markup notations are neat and simple, but keyword labels are better for a larger vocabulary. In MyWord an author can choose any symbolic or keyword labels, including standard HTML tag names.

The next example uses the HTML `h2` tag for a header, and the HTML `cite` tag for a citation:

sect
	demo
		h2  A Header Line

		The {cite Alice In Wonderland} story.
	&
		cite ..  <-  <cite>
		h2 .. <- <h2 style='margin:0'>

Using the `cite` tag to label the book title is a better semantic descriptor than using a `*` quote notation for italics or emphasis. For simple notes the author may be satisfied with italics on the grounds that human readers will naturally deduce the semantic intent from the context. More complex commercial or technical documents may require a larger vocabulary with more specific semantic markup tags.

In MyWord the author can choose a vocabulary of markup notations to suit any desired degree of semantic detail, and new notations can be defined as required.

##	Markup Notations

Simple documents only require a small set of markup notations for: headings, italics, bold, links, lists, and a few other things. These are the features provided in light-weight markup languages such as Markdown. They are also the basic features of a WYSIWYG (What You See Is What You Get) editor, as used for emails or blog notes and the like.

For example, MyWord can mimic popular Markdown notations:

sect
	demo
		###  Level 3 Header
		####    Level 4 Header

		Inline elements: *italic*, **bold words**,
		and `plain text`.

		*  Bullet point list.
		*  Second bullet point.
		*  Third bullet point.

		A link to the <http://www.csszengarden.com> web-site.

In MyWord these notations are not built-in, they are provided by a "lingo" of markup notations that the author can select and extend as desired.

In MyWord the markup can be expressed using a variety of different notations, as seen in the previous examples. The notations themselves do not have any pre-defined meaning. The meaning assigned to each notation can be chosen to meet the authors requirements.

###	Block Notations

A block notation is simply a first word *label* followed by a block of *content*. The content starts with the second word and may continue with any number of indented lines (inset with a tab or 4 spaces). The whitespace indentation is not part of the content.

Here are some examples:

demo
	###  A Header Line

	A line of text, the first word is not a label.

	box:
		A box of text...

		box:
			###  Another Header

			box: A box in a box in a box...

		More content text...
&
	box: ..  <- <div style='border:thin solid gray; margin:5pt 10pt'>

The label will typically be a short word using symbol characters. The header notation uses a `###` symbol to generate an HTML `<h3>` header element (like Markdown). The `box:` label generates an HTML element that CSS style rules have rendered as a box with a border.

Any word *could* be defined as a label, but then that word can no longer be used as a normal first word. This example uses `box:` as a block label, so the word `box:` can not be used as a normal first word. If this is a problem then a space at the start of the line is all that is needed (that will make it into the second word in the line).

You might like to play around with this example to see how this works. Just click into the left hand side and edit the text. For example, try putting a `box:` label as the first word of the line of text under the header. Don't worry your editing will not destroy anything, it is only in your private copy sand-box.


###	Paragraphs

A paragraph is simply one or more lines of text that do not start with a label. A paragraph is terminated by a blank line, or a line with a label.

By default the HTML presentation will wrap long lines to fit inside the available display width, and preserve any explicit line breaks inside a paragraph. This gives the HTML presentation the same general layout as the source text:

demo
	A line of prose with a
	line break.

If the author prefers to treat line breaks inside a paragraph as insignificant (the HTML default) then that can be done with a CSS style rule:

sect
	demo
		A line of prose with a
		line break.
	&
		@css
			span.newline { white-space:normal; }

###	Inline Notations

Quote marks make a nice notation to markup common elements:

sect
	demo
		Nice "quote marks" markup.

		For code `if (x>y) p=q` it's back-tick quotes.

		Some **bold and *italic* text** markup.

	&
		" .. "    <- <q>
		* .. *    <- <i>
		** .. **  <- <b>
		` .. `    <- <code> text
&
	" .. "   <- <q>
	@css
		q {quotes: '\201C' '\201D'; }
		q:before {content: open-quote; }
		q:after  {content: close-quote; }

For brackets, any sequence of symbol characters may be used in mirror image:

sect
	demo
		The *<The Alice in Wonderland>* story.

		A ~(fancy looking)~ note.

		*<Alice through the ~(looking glass)~>*
	&
		*< .. >*	 <- <i style='color:firebrick'>
		~( .. )~	 <- <b style='color:blue; background:yellow'>

A curly-bracket notation may be used to enable keyword labels to be used inline:

sect
	demo
		Some {em for emphasis} markup.

		Hit the {button return} key.

		Some {warn dangerous} markup.

	&
		em ..  <- <em>
		button ..  <- <button>
		warn ..  <- <span style='color:red'>

A place-holder notation allows an author to represent any markup element with simple square bracket notation that can be dropped into the prose narrative. The place-holder can be defined later, for example the place-holder may represent a link or an image.

sect
	demo
		The [Zen Garden] web-site.

		The GO Gopher: [gopher]

	&
		[Zen Garden]  <- link http://www.csszengarden.com
		[gopher]      <- image images/gopher.png

		image :: (_, url) => `<img src='${url}' height=40 width=60 />`

An HTML link or image requires a URL, but putting that information into the inline markup would disrupt the prose narrative. The definition of the place-holder notation is quite separate from the inline notation itself, the definitions will be discussed shortly.

Most markup notations naturally correspond to HTML elements, but some are symbolic labels that stand for an entity without any content.

Symbolic labels can be defined to directly represent HTML entities:

sect
	demo
		It's Joe's <- nice apostrophes.
		---
		X\/Y <: Z
	&
		'	 <- &rsquo;
		---	 <- <hr/>
		\/	 <- &cup;
		<:	 <- &isin;
		<-	 <- &larr;

Entity labels are not restricted to symbol characters, any word that starts with a symbol character can be used as an entity:

sect
	demo
		\top-hat :smiley: ^1
	&
		\top-hat  <- &#127913;
		:smiley:  <- &#x1f600;
		^1        <- &#x1F44D;


##  Markup Translation

Any modern browser can load a MyWord translator as JavaScript in an HTML page, and this will enable the browser to directly read and translate plain text source files that contain MyWord markup notations.

The translator requires a markup sheet to define the desired markup notations. A small markup sheet to mimic Markdown-like notations may be all that is required:

demo
	&
		# ..     <- <h1>
		## ..    <- <h2>
		### ..   <- <h3>
		#### ..  <- <h4>

		> ..     <- <blockquote>
		* ..     <- <div class=list-point>

		* .. *    <- <i>
		** .. **  <- <b>
		" .. "    <- <q>
		` .. `    <- <code> text

		[ .. ]  <- asdefined
		{ .. }  <- inline

These `metamark` rules define the markup notations. They can be included in the source text using a block with a `&` label, or they may be in a separate file with a `.mmk` suffix.

A definition rule begins with a skeleton signature for the markup notation. So `## .. ` is a skeleton signature for a `##` block notation. The dots `..` in the signature indicates the content. The `<-` is an operator that defines the notation in terms of HTML, and/or a content type transformation.

The `metamark` rules make the document self defined with its own "cheat sheet". This enables people to understand the source text, and enable software to translate the markup notations into HTML for publication.

MyWord comes with default markup sheet that defines Markdown like notations. For simple documents the author can use MyWord much like Markdown, without the need to define any new notations.

A MyWord markup sheet is used to define how the *input* notations translate into HTML elements. A CSS style sheet is used to define the *output* format for the presentation of HTML elements.

##	Definitions

The following examples repeat the previous examples together with `metamark` rules that define the markup notations.

###  Block Labels

The content of the `&` definition block uses the `metamark` definition language to assign markup notations a semantic meaning.

sect
	demo
		### A Header

		box: A box of text..

		&
			### ..  <- <h3>
			box: ..  <- <div class=box>
	&
		@css .box { border: thin solid gray; }

The `###` block label is defined to mean an HTML `<h3>` header, and the `box:` block label is defined to mean an HTML `<div class=box>` element. Then CSS style rules have been used to present the `box` element with a border.

A block label can use any characters other than white-space, and the content of the block has no restrictions, the end of the content is delimited by the indentation.

A block label can be defined to represent *any* HTML element the author desires.

For example, symbolic labels can be defined to represent HTML list elements and HTML list-item elements:

demo
	1..
		- First numbered point
		- Second point
			i..
				- First sub-point.
				- Second point.
		- Last numbered point.

	&
		1.. ..  <- <ol>
		i.. ..  <- <ol style="list-style-type:lower-roman">
		- ..    <- <li>

###	Inline Markup

In a paragraph of prose an inline markup notation can use quote marks or brackets to delimit the content.

Quote marks are defined with the same symbols before and after dots `..` that indicate the content:

sect
	demo
		Some "quotes" for **bold words** and *italics*.

		&
			* .. *     <- <i>
			** .. **   <- <b>
			" .. "     <- <q>

Brackets are defined using mirror image open and close symbols:

sect
	demo
		Some *(star struck)* text.

		The *<Alice In Wonderland>* book.

		&
			*( .. )*  <- <em>
			*< .. >*  <- <cite class='book' style='color:firebrick'>

By convention quote marks can be combined with parentheses in order to allow quote marks in the content:

sect
	demo
		Some *(italic with nested **bold** text)*.

		&
			*( .. )*  <- <i>
			** .. **  <- <b>

The [Critic Markup] notations have been designed to help with document editing. They use bracket notations that can be defined like this:
&
	[Critic Markup] <- link http://criticmarkup.com

sect
	demo
		Don't say {--to people that --}the world owes you a living....

		Keep up the good work{++ and people will help++}.

		&
			{-- .. --}   <- <del>
			{++ .. ++}   <- <ins>

A symbol may be defined as a block label, and the same symbol may also be defined as an inline quote notation:

sect
	demo
		* The *first* point.
			* A *sub-point* here..
		* The *second* point ...

		&
			* ..    <- <div style='display:list-item; margin-left:40px'>
			* .. *  <- <em>

###  Inline Keyword Labels

The markup sheet has defined curly-brackets as a key-word notation with an `inline` type. This means that the first word of the content may be defined as a keyword notation. For example:

sect
	demo
		Some {em for emphasis} markup.

		Hit the {button return} key.

		Some {warn dangerous} markup.

		&
			em ..  <- <em>
			button ..  <- <button>
			warn ..  <- <span style='color:red'>

###  Place-holder Markup

The markup sheet has defined square brackets as a place-holder notation with an `asdefined` type transform, which allows each place-holder to be defined later:

sect
	demo
		The [Zen Garden] web-site.

		The GO Gopher: [gopher]

		&
			[Zen Garden]  <- link http://www.csszengarden.com
			[gopher]      <- image images/gopher.png
	&
		image :: (_, url) => `<img src='${url}' height=40 width=60 />`

The square brackets are all that is needed to markup the author's place-holder text. Later the place-holder is defined as a `link` to a URL, or an `image` URL.

The place-holder could have been defined directly as any HTML element (as in earlier examples), but in this case it is easier to name a `link` or `image` transform to generate the required HTML element.

###	Symbolic Entities

Symbol characters can be defined as an entity without any content:

sect
	demo
		It's Joe's <- nice apostrophes.
		---
		X\/Y <: Z

		&
			'    <- &rsquo;
			---  <- <hr/>
			\/   <- &cup;
			<:   <- &isin;
			<-   <- &larr;

Any word that starts with a symbol character can be used as a markup notation to represent any replacement text:

sect
	demo
		\top-hat :smiley: ^1

		&
			\top-hat  <- &#127913;
			:smiley:  <- &#x1f600;
			^1  <- &#x1F44D;


##	Type Transforms

A markup notation can often be directly defined as an HTML (or XML) element, and by default the content will be translated as MyWord markup that may contain nested MyWord markup (in the same way that HTML elements can contain nested HTML).

However, sometimes the author may want the content to contain some other kind of markup language, or plain text without any markup language (so that markup notations will be presented as literal text). To do this the definition of a markup definition can name a type transform to specify how the content should be translated.

For example, if back-tick quote marks are defined as a notation for plain text source code, then the content should be interpreted as literal text, regardless of any nested markup notations:

demoH

	Italics for maths *(`a*b+c*d`)*

	Some *(``italic with `nested` text``)*.

	&
		*( .. )*  <- <i>
		` .. `    <- <code> text
		`` .. ``  <- <code> text

In this example star quotes are used for emphasis, and the back-ticks for plain text, with a `text` type. By default the content is interpreted as nested MyWord. But the definition for the back-tick quotes specify a `text` type transform so that the content is presented verbatim (which mimics Markdown).

A block label may be used to present programming language code as `text`:

sect
	demoH
		.js
			// sample JavaScript ...

			const greet = (who) =>
			console.log(`Hello ${who}!`)

			greet("World") // Hello World!

		&
			.js ..  <- <pre class='js'> text
	&
		@css .js {background:lemonchiffon;}

The `text` type is plain source text, but in general the content text can be any type. A type transform can be used to translate any desired source text language into HTML.

For example, MyWord can mimic the Markdown angle-bracket notation for a URL. In this case the content is a URL that is translated into an HTML link:

sect
	demoH
		A URL <www.csszengarden.com> link.

		But <this *and* that> is not a link.

		&
			< .. >   <- linkURL
	&
		linkURL :: (contents) =>
		  ((/(?:(?:^[a-z](?:[-a-z0-9+.])*:\/\/)|(?:^[\/]?[^\s\/]+[\/.][^\s]+)|(?:#))\S+$/.test(contents.trim()))
		  ? `<a href='${contents.trim()}'>${contents}</a>`
		  : ['&lt;', markit('prose', contents), '>'].join(''))

The `linkURL` transform will check if the text content is a valid URL format. If it is, then the transform will generate an HTML link element. If not, then then the text will be translated as normal, as in the second example (since a URL can not contain white-space).

Braces can be used as a markup notation for text that starts with a keyword label. The `inline` transform can be used to apply keyword definitions to the content of the braces:

sect
	demoH
		Some {hot pepper curry}.

		Some {mild spicy peas}.

		&
			{ .. }   <- inline
			hot ..   <- <span class=hot>
			mild ..  <- <span class=mild>
	&
		@css
			.hot { color:red; }
			.mild { color:green; }

The place-holder notation is very similar. The square bracket notation uses an `asdefined` transform to find a definition that matches the content text:

sect
	demoH
		The [Zen Garden] web-site.

		The GO Gopher: [gopher]

		&
			[ .. ]        <- asdefined
			[Zen Garden]  <- link http://www.csszengarden.com
			[gopher]      <- image images/gopher.png
	&
		image :: (_, url) => `<img src='${url}' height=40 width=60 />`

Square brackets are a traditional notation that is used for various kinds of references. The MyWord place-holder notation follows this convention.

If *every* place-holder is expected to have it's own definition, then any *undefined* place-holders can be highlighted. This is very helpful for editing an incomplete draft:

sect
	demoH
		The [Alice Through The Looking Glass] story.
	&
		@css .Undefined { background:yellow; }

Notice that the square brackets for place-holder elements, and the braces for inline elements, are not built-in notations. If an author wants to use square brackets in prose for some other purpose, then the place-holder notation can be re-defined with some other pair of bracket symbols.


##	Transform Definitions

MyWord can deliver the full power of HTML (or XML) markup without the need for any type transforms. However, type transforms can extend MyWord in many useful ways. We have seen examples using transforms that are pre-defined in a markup sheet for the default lingo.

The `metamark` language can define a type transform as a JavaScript function. The default lingo can thus be extended with any desired custom type transforms.

Type transforms can be used to translate languages for a wide range of different applications, such as mathematics, or diagrams, and many other purposes. The transforms may also employ third-party transform functions.

MyWord documents are modular, they can include blocks of content from other files. An `include` transform can be used to include the content of a URL into a MyWord document.

Most authors will not need to define a custom transform. However, MyWord makes it quite easy to define new transforms, but that is beyond this introductory document.


##  Publishing MyWord Documents

The previous sections of this introduction focus on how to compose MyWord content. The next step is to "publish" that content so it can be rendered in a Web page on a browser.

Unlike `.html` and a few other file types, standard browsers don't recognize `.myw` files as content that can be rendered. So each MyWord document requires a "host" `.html` file to bridge this gap. In addition to referencing the MyWord document root, it loads the MyWord application software to perform the translation on the document contents.

A MyWord "translator" can generate an HTML host file given the URL of a MyWord source text.

A minimal HTML host looks like:

eg
	<!DOCTYPE HTML>
	<html>
	<head>
		<meta lang=en charset="UTF-8">
		<script src='lib/x-markup.js'></script>
	</head>
	<body>
		<div class=x-markup src=myMyWordDoc.myw></div>
	</body>
	</html>

A standard browser can load this HTML file, and the script will automatically load a markup sheet with definitions for the default lingo, and use that to translate the `myMyWordDoc.myw` source text.


##	Getting Started

A browser is required to view published MyWord documents but browser access to the local file system is commonly restricted for security reasons. Configuring the browser to get around this issue is possible, but it's often simpler to just run a local web server to serve MyWord content.

The first step is to download the [current release of MyWord] or visit the [GitHub project site] for more choices. Uncompressed, the download should have a directory structure like:

.box
	MyWord-master/
	|
	|-- LICENCE
	|
	|-- README.md
	|
	'-- dist/
		|
		|-- lib/
		|
		|-- pkgs/
		|
		|-- ReadMe.html
		|
		'-- ReadMe.myw

Next create a directory to act as your server root directory. For the purposes of this exercise, we'll use `~/MyServer`, i.e., the directory `MyServer` in the top level user directory. Copy the contents of the MyWord release `dist` directory into it:

.box
	~/MyServer/
	|
	|-- lib/
	|
	|-- pkgs/
	|
	|-- ReadMe.html
	|
	'-- ReadMe.myw

While many options for running a local server exist, a simple solution using [Node.js] and the [`local-web-server`] npm package. Download and install your platform specific version of Node from the web-site.

The remaining steps to setup your local server require the use of a command line interface (CLI). If Node is properly installed, the Node Package Manager (`npm`) command will be available to the CLI. Use it to install the `local-web-server` package (command prompts are indicated by `$`, example output also shown):
eg
	$ npm install -g local-web-server

	/usr/local/bin/ws -> /usr/local/lib/node_modules/local-web-server/bin/cli.js
	+ local-web-server@2.4.0
	added 160 packages in 9.829s
Note: You may require root privileges to install `npm` packages on your computer. Prefixing the `npm` command with `sudo` will temporarily enable root privileges on Unix based systems.

A local server can now be started using the `ws` command and specifying a server root directory:
eg
	$ ws -d ~/MyServer

	Serving at http://localhost:8000, http://127.0.0.1:8000, http://192.168.1.9:8000

To test that the server is running, try URL `localhost:8000` on your browser; you should see a view of the server root directory. Click on the `myword` directory and then on the `ReadMe.html` file to see the published view. To stop the server, type `Ctrl-c` on the CLI.

Should you edit the content of the `ReadMe.myw` file, you won't need to update the `ReadMe.html` file; re-loading the web page will show the latest version of the MyWord document file. To add new content, copy the document `.myw` and host `.html` files to `~/MyServer`.

There are many other options available with the `local-web-server`. By installing the [`myword` middleware] package, `local-web-server` can even be configured to serve MyWord files directly, with one-click, and without the need for an HTML "host" file. But any web server can be used to serve MyWord documents.
&
	@import pkgs/box.mmk
	@css pre.my_box {margin:0px; background:whitesmoke; padding-left:20px}
	[current release of MyWord]  <- link https://github.com/ridgeworks/MyWord/archive/V1.0.zip
	[GitHub project site]  <- link https://github.com/ridgeworks/MyWord
	[Node.js]              <- link https://nodejs.org
	[`local-web-server`]   <- link https://www.npmjs.com/package/local-web-server
	[`myword` middleware]  <- link https://www.npmjs.com/package/lws-myword

##	Conclusion

MyWord markup can be used in much the same way as a light-weight markup language such as Markdown. The MyWord markup notations can mimic the easy to read Markdown notations. The difference is that MyWord is extensible, and authors can define their own markup notations for their own purposes.

This means that MyWord documents do not depend on a set of feature defined in the code of an external translator. Instead the MyWord markup notations are chosen by the author so that the document is self defined. A MyWord document together with its markup definitions can be loaded directly into any modern browser using a generic JavaScript translator.

In a markup language such as Markdown the author must fall back to HTML for any features outside the built-in features of a particular Markdown translator. With MyWord the author can define custom markup notations to represent any desired HTML. The markup notations can be extended to suit any particular topic, and to suit the authors personal preferences.

The MyWord notations can be defined in terms of HTML or XML, and custom text transforms (if required) can be defined using JavaScript. This ensures that MyWord documents will survive for generations, since their only external dependency is a standard web-browser. Browsers are rapidly evolving, but they have a strong commitment and incentive to remain backward compatible in order to preserve the millions of HTML web pages already published on the Internet.

In fact, since a MyWord document (including the markup definitions) is easy to read as plain text, there is no essential external dependency at all.

&
	@import MyWordDocStyle.mmk pkgs/demo.mmk pkgs/toc.mmk
	TOC> .. <- toc 2 2

