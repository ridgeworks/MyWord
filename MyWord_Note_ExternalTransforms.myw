##  Using External Transform Functions

In MyWord, a transform function is simply a JavaScript function that takes the markup element's content text and returns the translated HTML as a string. Simple transforms can be written as @grit[Grit] rules in metamark blocks along with normal label defintions:

:blockquote  `(transform :: (content) => function code...)

But if the transform is too complex to be implemented as a simple function, or if there are commonly available JavaScript modules that provide functions with the required signature (input = *(`(string)), returns *(`(HTMLstring))), it may be more convenient to load these from standard JavaScript files. Any global function names provided by such files are automatically available as transform functions to MyWord.

Since the MyWord translator runs in a Web Worker, there are some constraints on the implementation of external transform functions. The global environment for a Worker is different than the global environment for JavaScript running as part of the main document. The main restriction is that a Worker cannot do anything which directly affects the parent page. This includes manipulating the DOM and using that page's objects. And to load the script into the Worker global space, the `(@import) statement must be used.

###  An Example, `(highlight.js)

@hilite(`(highlight.js)) is a popular package used to provide syntax coloring for over 150 languages in more than 70 styles. Assuming a standard download configuration, the first step is to instruct MyWord to load the JavaScript along with a selected style:

.eg  &  @import highlight.pack.js styles/xcode.min.css

(Note: the filepaths may vary depending on the file system structure containing the document. All relative pathnames are relative to the file containing the `(@import) statement.)

The highlight module, `(hljs), contains a function `(highlightAuto) that almost does what we want; the problem is that the HTML return string is a property (`(value)) of the return value. So we have to define a simple wrapper to act as the transform function:

.eg   &  highlight   :: (content) => hljs.highlightAuto(content).value

And now we can define labels which use this transform to syntax color blocks of code. From @intro(Introduction to MyWord),

.demo
    A snippet of Python code:

	.py
		# this a blob of Python code
		if x > 42:
			print 'end of </script>.'

    &   .py = <pre class=py> highlight

It's often convenient to package up the `(@import)'s and the auxiliary transforms (and maybe even label definitions) in their own package file, e.g., `(highlight.mmk) (again filepaths are dependant on file system configuration):

.eg
  @import highlight.pack.js
          styles/xcode.min.css
  highlight   :: (content) => hljs.highlightAuto(content).value

and just import the package:

.demo
  Some HTML:
  .htm
    <!DOCTYPE HTML>
    <html>
    <head>
    <meta lang=en charset="UTF-8">
    <title>Grit Grammar Parser</title>
    <script src='lib/x-markup.js'></script>
    </head>
    <body>
        <script type=text/x-markup.myword>
    @include  GritGrammarParser.myw
        </script>
    </body>
    </html>

  and JavaScript:
  .js
    function myFunction() {
        var str = "The rain in SPAIN stays mainly in the plain";
        var res = str.match(/ain/g);
        document.getElementById("demo").innerHTML = res;
    }

  and CSS:
  .css
    .pre { margin-left:20pt; }

    table.array {border-collapse:collapse;}
    .array td { border:thin solid gray; padding:2pt 10pt; }


    .eg {
        padding-left:10pt; padding-right:30pt;
        white-space:pre; font-family:monospace; background:whitesmoke;
    }

  &  @import highlight.mmk
     .htm = <pre class=htm> highlight
     .js  = <pre class=js> highlight
     .css = <pre class=css> highlight

###  Another Example, `(marked.js)

In MyWord, the translation of a labelled block is determined by the label definition which includes the identity of the transform function. So it's possible to embed blocks of text written in other lightweight markup languages, e.g., MarkDown, if the appropriate transform function is made available. @marked(`(marked.js)) provides just such a transform for MarkDown. Once it's `(@import)ed, the global `(marked) function it defines can be used directly:

.demo
    &   .md = marked
    .md
		A First Level Header
		====================

		A Second Level Header
		---------------------

		Now is the time for all good men to come to
		the aid of their country. This is just a
		regular paragraph.

		The quick brown fox jumped over the lazy
		dog's back.

		### Header 3

		> This is a blockquote.
		>
		> This is the second paragraph in the blockquote.
		>
		> ## This is an H2 in a blockquote

		Some of these words *are emphasized*.
		Some of these words _are emphasized also_.

		Use two asterisks for **strong emphasis**.
		Or, if you prefer, __use two underscores instead__.

		Unordered (bulleted) lists use asterisks, pluses, and hyphens (*, +, and -) as list markers. These three markers are interchangable; this:

		*   Candy.
		*   Gum.
		*   Booze.

		this:

		+   Candy.
		+   Gum.
		+   Booze.

		and this:

		-   Candy.
		-   Gum.
		-   Booze.

		Ordered (numbered) lists use regular numbers, followed by periods, as list markers:

		1.  Red
		2.  Green
		3.  Blue

		If you put blank lines between items, youâ€™ll get paragraph tags for the list item text. You can create multi-paragraph list items by indenting the paragraphs by 4 spaces or 1 tab:

		*   A list item.

			With multiple paragraphs.

		*   Another item in the list.

		LINKS

		Markdown supports two styles for creating links: inline and reference. With both styles, you use square brackets to delimit the text you want to turn into a link.

		Inline-style links use parentheses immediately after the link text. For example:

		This is an [example link](http://example.com/).

		Optionally, you may include a title attribute in the parentheses:

		This is an [example link](http://example.com/ "With a Title").

		Reference-style links allow you to refer to your links by names, which you define elsewhere in your document:

		I get 10 times more traffic from [Google][1] than from
		[Yahoo][2] or [MSN][3].

		[1]: http://google.com/        "Google"
		[2]: http://search.yahoo.com/  "Yahoo Search"
		[3]: http://search.msn.com/    "MSN Search"

		The title attribute is optional. Link names may contain letters, numbers and spaces, but are not case sensitive:

		I start my morning with a cup of coffee and
		[The New York Times][NY Times].

		[ny times]: http://www.nytimes.com/

Notice that this example works because all the link definitions are contained in the block; link definitions are not shared between blocks.

Because the label defintion (`(.md)) is in the form of a file suffix, MarkDown content can be loaded from files using `(@include) label defined in the @lingo(default lingo), e.g.:

.eg  @include  someDoc.md

###  Summary

External global functions that meet the transform function signature requirements can be loaded into the MyWord Worker global space using `(@import). Any such global function is automatically accessible as a MyWord transform. `(metamark) packages provide a convenient way to bundle `(@import)'s (JavaScript, CSS, and other `(metamark)) with other transform and label defintions to provide modularity and ease of reuse.


&   @grit   = <a href='http://ridgeworks.github.io/MyWord/GritGrammarParser.html'>
    @hilite = <a href='https://highlightjs.org/'>
    @intro  = <a href='http://ridgeworks.github.io/MyWord/MyWord.html'>
    @lingo  = <a href='http://ridgeworks.github.io/MyWord/MyWordLingo.html'>
    @marked = <a href='https://github.com/chjj/marked'>
    @import 3rdparty/Beautify/beautify.mmk
    @import 3rdparty/marked.js
    @docstyle = stylelink stylesheets/myword_std.css
    stylelink :: (_, url) => `<link rel='stylesheet' type='text/css' href='${markit('text', url.trim())}'>`

@docstyle()
