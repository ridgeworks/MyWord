#   MyWord Reference

MyWord is an extensible markup language, just like XML or HTML (with custom tags). A MyWord *label* is an easy-to-read shorthand that can represent any HTML element. A dictionary of label definitions establishes the vocabulary of a MyWord markup language, know as a *lingo*.

In a nutshell:

-	A MyWord document is read as lines of text that are grouped into blocks.

-	The first word in a block may be a label, the remainder is the content text.

-	The content of a block has an associated *type* which defines the 'meaning' of the content. The definition of a block label includes the type of the content.

-	A MyWord document has content of type `myword`.

-	Blocks without a label are normal paragraphs of prose (type `paragraph`).

-	Blank lines are used to separate blocks (where necessary) and can be used for vertical spacing (type `blankline`).

-	`paragraph` content may be marked up with inline notations.

-	Authors can define a vocabulary of block labels and inline notations for their own markup language.

-	There are no special syntax characters required to parse the block structure.

-	Inline notations do use special characters, but a general character escape mechanism can be avoided by defining alternative equivalent notations.

-	The translation of content into HTML (or XML) is determined by the content type, as specified in the label defintions.

-	A standard browser can be empowered to read MyWord documents directly and present them as HTML.

An important consequence of not requiring any reserved syntax characters for parsing the block structure is that there are no restrictions on the block content. This allows the author to write content text that can contain any data format, notation, markup, or programming language.

##	Blocks

The first word in a block of text is a label if it has an offset format, otherwise it is simply the first word in a paragraph of prose. The offset format separates the label from the content text with a tab character or two or more space characters, or with an indented line.

Here is an example of a MyWord document with the source text is on the left, and the HTML presentation is on the right:

demoS
	title:    The Title

	author:   The Author

	This is a one line paragraph of prose.

	Another paragraph of prose. This
	one has more than one line.
	but there can be no blank lines
	in a paragraph.

	foot:
	  This is in a block of text that can
	  have any number of indented lines,
	  including blank lines.

	  It can contain nested blocks.


This example has three block labels for `title:,  author:, and foot:`. These labels should be self evident, but they have not yet been defined, they are recognized as labels simply because of their offset format.

Block labels that are undefined can highlighted in the HTML presentation of the document, as shown on above using a yellow background. (This presentation is controlled by a CSS rule but is normally set to just display the block as pre-formatted, monospaced text.) An author will normally employ a standard lingo, that is, a pre-defined vocabulary of labels. New block labels can be invented as required and defined within the document.

A block label must start at the left margin, and the block may contain any number of indented lines of text. The block can contain blank lines, so the block will continue until the next line that is not indented from the left margin, or the end of the document.

If the first word is not a block label then the block is a paragraph of *prose*. A paragraph may contain any number of lines, provided the lines do not start with a offset label, and are not blank or empty. By default, each line of text inside a paragraph of prose will be rendered as a separate line. (This can be changed via CSS to flow the lines together like the standard way that HTML presents text in paragraph elements.) The prose may contain inline notations, but there are none in this first example.

Block labels can be defined to represent any HTML elements, for example:

	demoS
		title:    The Title

		author:   The Author

		This is a one line paragraph of prose.

		Another paragraph of prose. This
		one has more than one line.
		but there can be no blank lines
		in a paragraph.

		foot:
		  This is in a block of text that can
		  have any number of indented lines,
		  including blank lines.

		  It can contain nested blocks.

	&   title: .. <- <h2>
		author: .. <- <h3>
		foot: .. <- <div class=foot>

		@css
		  h2, h3 { text-align: center; }
		  .foot { border-top: thin solid gray; font-size: small; }

##	Block Content

The content text is the remainder of the block after the label. The block ends at the next line that is not indented under the markup label. This allows the content text to contain any characters without restriction, there are no special syntax characters to be escaped.

This is different from most other markup languages, data languages, and programming languages. It is common practice to delimit a block of text with special syntax character(s), such as quotes or brackets. This restricts the content text since the syntax character(s) can not be allowed inside the content (an escape syntax is required).

A length count is a perfect way to denote the end of a block of text that can contain any characters without restriction. Unfortunately a length count is impractical in documents that can be manually edited in a plain text editor.

The use of indentation to determine the end of a block of text is simple and intuitive, it is a good pragmatic alternative to a length count. MyWord uses a simple but flexible indentation scheme:

-   A content line may be inset using one tab character for each level of indentation.

-   A content line may be inset using 2 to 8 space characters for each level of indentation. A single space at the start of a line is not an inset indentation.

-   When spaces are used, the minimum inset in a block determines the number of spaces for the first level of indentation.

-   The inset for one level of indentation is deleted from every line to extract the content text, so that it starts at the left margin.

An indented block may be inset with tabs or spaces (2 to 8), but not a mixture.

The white-space offset following the label, and the inset of indented lines, is all part of a skeleton format. The skeleton delimits the block content, but it is not part of the content text.

An indented block of text without a label is treated as a block with an empty label whose content type is *insetblock*. A type defintion (similar to a label defintion) can be used to specify how indented blocks are to be translated.

The block structure is parsed breadth first, the content of a nested block is only parsed after the outer levels have been parsed. This is important since the MyWord block grammar is not necessarily the grammar that will be used for the content of a block. The content grammar is determined by the block label definition. This breadth before depth parsing process enables the composite grammar to be context sensitive.

###  Content Syntax

The use of indentation allows `myword` content to be nested:

    demoS
        title:    The Title

        author:   The Author

        This is a one line paragraph of prose.

        .box
            title:    The Title

            author:   The Author

            This is a one line paragraph of prose.

            Another paragraph of prose. This
            one has more than one line.
            but there can be no blank lines
            in a paragraph.

            foot:
              This is in a block of text that can
              have any number of indented lines,
              including blank lines.

              It can contain nested blocks.

        Another paragraph of prose. This
        one has more than one line.
        but there can be no blank lines
        in a paragraph.

        foot:
          This is in a block of text that can have any number of indented lines, including blank lines.

          It can contain nested blocks.

    &   title: .. <- <h2>
        author: .. <- <h3>
        foot: .. <-  <div class=foot>
        .box .. <-  <div class=box>

        @css
          h2, h3 { text-align: center; }
          .foot { border-top: thin solid gray; font-size: small; }
          .box { border:thin solid gray; }

The `.box` label specifies type `myword` the default myword grammar, but the `.box` label can be replaced by a `.viz` label that specifies content type `text` that simply quotes the source text verbatim:

    demoS
        title:    The Title

        author:   The Author

        This is a one line paragraph of prose.

        .viz
            title:    The Title

            author:   The Author

            This is a one line paragraph of prose.

            Another paragraph of prose. This
            one has more than one line.
            but there can be no blank lines
            in a paragraph.

            foot:
              This is in a block of text that can
              have any number of indented lines,
              including blank lines.

              It can contain nested blocks.

        Another paragraph of prose. This
        one has more than one line.
        but there can be no blank lines
        in a paragraph.

        foot:
          This is in a block of text that can
          have any number of indented lines,
          including blank lines.

          It can contain nested blocks.

    &   title: .. <- <h2>
        author: .. <- <h3>
        foot: .. <- <div class=foot>
        .viz .. <- <pre class=box> text

        @css
          h2, h3 { text-align: center; }
          .foot { border-top: thin solid gray; font-size: small; }
          .box { border:thin solid gray; }

Other blocks may have content with other types. For example, the `.array` label uses a grammar that allows the layout of its content text to represent a table:

    demoS
        .array
            1    One      Line
            2    Two      Area
            3    Three    Volume

    &   .array .. <- <table class=array> tsv
        tsv := row*                   :: (rows) => this.flatten(rows).join('')
            row   := tsep* cell* nl?  :: (_,cell) => ["<tr>",cell,"</tr>"]
            cell  := item tsep?       :: (item) => ["<td>",this.flatten(item).join('').replace(/</g,'&lt;'),"</td>"]
            item  := (!delim char)+
            delim :~ %tsep | %nl
            tsep  :~ [\t]|[ ]{4,}
            nl    :~ [\n\f]|([\r][\n]?)
            char  :~ [\s\S]


        @css
            table.array {border-collapse:collapse;}
            .array td { border:thin solid gray; padding:2pt 10pt; }

##  Prose Paragraphs

Lines of prose (i.e., lines that do not begin with a block label or indent) are collected together into paragraphs until the next block or blank line occurs. Within a paragraph, control characters, including line-breaks and tabs, are translated into `<span>` HTML elements, which allows CSS rules to control how these are presented. By default, line-breaks are honoured so paragraph lines correspond to source lines, rather than flow together into a line length that fits the width of the presentation. Spaces and tabs get the standard HTML presentation; any number of them get translated into a single space between words.

demoS
    The default:
    This is the first line,
    and the second line.

A CSS rule can be used to revert to standard HTML presentation:

    demoS
        This is a paragraph  with
        lines that
        flow together.

    &   @css span.newline {white-space:normal;}

###  Inline Notations

Paragraph content uses a standard prose grammar by default. The prose grammar enables markup of pieces of the paragraph content using inline notations. One kind of an an inline notation is a quote, which uses the same character sequence to delimit the content:

demo
	Nice "quote marks" markup.

	A code fragment: `if (x>y) p=q`.

	Some **bold and *italic* text** markup.

This example uses four different quote notations: `"` for a double quote, `(`)` for monospaced code fragments, `**` for bold text, and `*` for italicized text. The end of the quote content is determined by the first occurence of the quote character sequence, so a quote sequence can't be part of the content. This can be circumvented by defining an equivalent alternative notation. This exampe just uses double `"`s and `(`)`s.

	demoS
		Nice ""quote with a " inside"" markup.

		A code fragment: ``var templ = `<span class='${my_class}'>```.

	&	"" .. "" <- <q class=my_dquo>
		`` .. `` <- <code class=my_text> text
In some cases more than one alternative may be required and they can be customized to accomodate whatever the content dictates.

An inline notation using brackets are similar to quotes, except the character sequences (or tag) delimiting the content of the notation are different, e.g., `[` and `]`, `(()` and `)`, etc. In fact the end tag, is the mirror image of the start tag. This can be generalized to any sequence of characters, e.g., `*|` and `|*`, or `**(` and `)**`. Bracket sequences like these are often a very natural way of delimiting content.

demoS
	`*` alternative using `(( .. ))` brackets: *(`x = y * z;`)*

	A link <http://example.com> using angle brackets.

Bracket notations have the additional advantage that they can nested, since the end tag is not the same as the begin tag.

A bracket/quote tag can be any sequence of ASCII characters except control characters (including spaces) and alphanumerics.

The final kind of inline notation is the symbol, which really has no content at all. The label definition for a symbol contains all the information to translate it to an HTML output, and is frequently used to represent HTML entities or to escape characters that might otherwise be interpreted as quote/bracket tags.

	demoS
			It's Joe's <- nice apostrophes.
			---
			w = x $* y $* z
			X\/Y <: Z
	&
		\/	 <- &cup;
		<:	 <- &isin;
		<-	 <- &larr;
		$*	 <- &ast;

In this example a single quote is replaced by a apostrophe, `---` becomes a HTML horizontal rule (although that's not quite in compliance with the HTML5 specification), and `$*` is a literal asterisk rather than a quote tag used for italics.

A symbol starts with a quote/bracket character (see defintion above) and ends with whitespace, so it can contain alphanumeric characters, unlike quote/bracket tags. In cases where a symbol is the same as a quote/bracket tag, the latter will take precedence. However, if the end tag is not found, it will be treated as a symbol. In any case, sequences that are quote/bracket/tags or symbols syntactically, but are not defined, are assumed to be literal text and translated verbatim.

Like labelled blocks, inline notations are defined using label defintions, as described below. The point here is that the prose grammar does not define the grammar of the content, it only defines the format for the markup structure. The label defintion specifies the grammar of its content, i.e., its type.

Unlike labelled blocks, the content of inline notations is not completely "syntax free". It can not contain an unbalanced closing bracket or quote tag. However, alternative notations can be defined to allow an odd different tag to be included.

##  Label Definitions

By convention the label & is used to define new labels.

Simple label definitions only need to specify the HTML tag that a label represents.

.eg
    &   label = <tag atts...>

The translation of the label markup into HTML will wrap the content text into a `[<tag atts...>] wrapper. This is all that is required to define a custom label in terms of any desired HTML.

A standard lingo can pre-define labels with the same names as standard HTML tag names. Many common HTML tag names are useful without the need for any attribute values.

.demo
    For :em[emphasis] and :strong[bold words].

    &
        :em = <em>
        :strong = <strong>

Of course it is not possible to pre-define a label for every possible tag and every possible set of attributes. However it may still be useful to pre-define a small vocabulary of labels to represent partcular HTML tag names with specific attibutes.

.demo
    This is ~warn[dangerous].

    &
        ~warn = <span style='color:red'>

Authors can define labels that are unique to a particular document, or even to a particular section of a document.


###  Label Scope

A label definition applies across all blocks at the same level (i.e. all sibling blocks), and is inherited by the children of the sibling blocks.

A label may be used before it is defined. The definitions (i.e. the & blocks) will be read first. If a label is defined more than once at the same level then the last definition will be used.

The resolution of a label will first consult definitions at the same level (i.e. definitions in a sibling & block), before consulting higher level definitions (i.e. definitions in a sibling of the parent block).

A label defined in a top level block will be the default for a label at any depth nested anywhere in the document, unless it is over-ridden by a local definition.

For example:

.demo
    Some :mark[top level] content.

    ~sandbox
        Some :mark[second level] content.

        &  :mark = <mark style="color:red">

    ~sandbox
        Some :mark[other second level] text.

    &
        :mark = <mark>
        ~sandbox = <div> myword

###  CSS Style

A label definition can specify an HTML element to represent the semantic meaning for the label. Following standard practice the presentation style is normally treated as a separate matter, and defined with CSS style sheet rules. Style sheets can be used as usual.

A `[<style>] element can be used together with a label definition anywhere in the structure of an HTML document. The style rules can also use the CSS `[scoped] property to specify that the styles only apply to this element's parent element and that element's child elements (not the entire document). This makes the style scope very similar to the label definition scope.

For example:

.demo
    .box
        This is an example box of text.

        .box
            This is a nested box.

            :style
                .box { border: thin solid red; }

        More in the outer box.

    :style
        .box { background: lightyellow;
                margin:10pt; padding-left:5pt; }

    &
        .box = <div class=box> myword
        :style = <style scoped> text

The `[:style] rule itself is defined in this example for completness. It would be more typical to use a label provided by a document wide lingo that pre-defined labels for all the standard HTML tag names.


###  Using A Lingo

A lingo is a defined vocabulary of labels. A lingo can be applied to a complete document (as the default) by including a copy of the lingo label definitions in a top level block of label definitions. But that is rather cumbersome, it is better to define a lingo in a separate file that can be shared across documents.

A document can import a lingo file by using a `[@import file-url] instruction:

.demo
    ##  Hello World

    There are lots of :em[riddles] in the
    book :cite[Alice In Wonderland].
.eg
    &  @import my-lingo.mmk

The `[.mmk] suffix indicates a meta-markup file type. This file type contains label definitions just as if they are inside a `[&] block:

.file  file: my-lingo.mmk
.body
    ...
    :cite = <cite>
    :em = <em>
    ...
    ...
    #   = <h1>
    ##  = <h2>
    ### = <h3>
    ...

&
    .file = <div class=file> text
    .body = <div class=body> text

:style
    .file { font-size:small; color:gray; font-style:italic; margin-left:10pt; }
    .body { background:whitesmoke; margin-left:10pt; white-space:pre; font-family:monospace;}

The MyWord markup language has no pre-defined labels other than the special & label for meta-markup definitions. This means that a lingo file is almost always required. For convenience a lingo file can be packaged together with the `[myword] translator. The author can therefore use a packaged version of MyWord just as if the lingo is built-in to the translator, without requiring an `[@import] instruction. How to package a MyWord translator into a browser will be discussed later.



##  Content Translators

When a label is defined simply as an HTML element, then the content text will be translated as prose by default.

The full form of label definition can specify an explicit transform function in addition to an HTML tag wrapper.

.eg
    &   label = <tag atts...> transform

The translation of this label into HTML will apply the specified transform function (i.e. the content translator) before the content text is wrapped into a <tag atts...> HTML element.

For example:

:div
    .demo
        .box
            .cap    Text in a :em[Box]

            Some .bag[text in a :em[bag]].

        :style
            .box { border:thin solid gray; padding-left:10pt; }
            .bag { border:thin solid red; padding:2pt; }

        &
            .box = <div class=box> myword
            .cap = <h2> prose
            .bag = <span class=bag> text
            :em  = <em>
            :style = <style scoped> text


The definition for a block label with block content should use the "myword" transform (e.g. the .box label).

If the block label only contains inline elements the the "prose" transform should be used (e.g. the .cap label).

The definition of a label as an HTML tag will use the "prose" transform by default (e.g. the :em label).

The standard "text" transform translates the content verbatim (e.g. the .bag and :style labels).

If the transform function generates HTML content that does not require an outer HTML wapper then the label definition may omit the HTML <tag> wrapper.


##  Transform Functions

Transform function can also be defined in much the same way as label definitions.

A basic transform function is simply a JavaScript function that takes the markup element's content text and returns the translated HTML (as a string, anything else is an error):

.eg
    transform :: (content) => function code...

The transform is defined with the standard JavaScript ES6 () => ... arrow syntax for a function definition. This is translated into ES5 JavaScript to allow a little backward compatibility with browsers using ES5 that do not support the ES6 arrow functions syntax.

For example, the @ label can be defined with a transform function to generate an HTML link for a URL:

.demo
    See the @[http://csszengarden.com] web site.

    &
        @ = linkURL

        linkURL :: (content) => {
            var url = markit('text', content);
            return "<a href='"+url+"'>"+url+"</a>";
            }

The `[@] label is defined with the `[linkURL] transform function. This function takes the content text as a URL web address and generates an HTML link to target that URL.

The special `[markit] function translates the content as `[text], which will escape any HTML syntax characters in the content text. The `[markit] function can apply any transform function to a text string.

The examples in this document are generated with a demo transform to show the source text on the left and the HTML presentation on the right. The definition of this transform uses the `[markit] function to translate the content as `[text], and as `[myword] markup:

.demo
    .demo
        Some :em[example] text.

    &
        .demo	= <table class='demo'> demo

        demo    :: (content) =>
                "<tr><td class='A1'>" +
                markit('code', content) +
                "</td><td class='B1'>" +
                markit('myword',content) +
                "</td></tr>"


More complex transform functions can be defined with a grammar.


###  Grammar Definitions

A transform function can be defined with a grammar using the Grit grammar parser. The Grit grammar rules supports Parser Expression Grammar rules plus regular expression rules, together with JavaScript semantic actions. A small example is shown here to illustrate how a transfrom function can be defined with a grammar.

The `[array] transform is defined with a grammar that enables the source text format to directly represents an array of elements. In an array format each line is a table row, and column fields are simply separated by white-space, either tabs or multiple space characters:

.demo
    .array
        1    One      Line
        2    Two      Area
        3    Three    Volume

    &  .array = <table class=array> array

:style
    table.array {border-collapse:collapse;}
    .array td { border:thin solid gray; padding:2pt 10pt; }

Here is the grammar that defines the `[array] transform:

.eg
    &
        array := row*                 :: (rows) => this.flatten(rows).join('')
            row   := tsep* cell* nl?  :: (_,cells) => ["<tr>",cells,"</tr>"]
            cell  := item tsep?       :: (item) => ["<td>",markit('prose',this.flatten(item).join('')),"</td>"]
            item  := (!delim char)+
            delim :~ %tsep | %nl
            tsep  :~ ([ ]*[\t]|[ ]{2,}) [ \t]*
            nl    :~ [\n\f]|([\r][\n]?)
            char  :~ [\s\S]

&
    array := row*                 :: (rows) => this.flatten(rows).join('')
        row   := tsep* cell* nl?  :: (_,cells) => ["<tr>",cells,"</tr>"]
        cell  := item tsep?       :: (item) => ["<td>",markit('prose',this.flatten(item).join('')),"</td>"]
        item  := (!delim char)+
        delim :~ %tsep | %nl
        tsep  :~ ([ ]*[\t]|[ ]{2,}) [ \t]*
        nl    :~ [\n\f]|([\r][\n]?)
        char  :~ [\s\S]

The grammar rules define a parse tree, and the associated semantic actions translate the tree nodes into HTML elements. For more information consult the Grit Reference document.

The `[array] transform translates the contents of each table cell using the `[prose] transform so that inline markup can be used.

The array transform can be used with different style rules to present tables to suite the application. Transforms like this can be included as utility functions in the vocabulary of a core lingo that can be bundled together with the MyWord translator.

More complicated transform functions, such as the translation of AsciiMath, can also be defined with grammar rules. The `[math:] label can be defined with the `[asciimath] function that translates AsciiMath notation into HTML Math ML elements. The `[math:] label and the grammar for the `[asciimath] transform function is defined in a separate file `[pkgs/asciimath.mmk], which can be used like this:

.demo
	math:
		sum_(i=1)^n i^3=((n(n+1))/2)^2

	&   @import pkgs/asciimath.mmk



##  Importing Resources

A MyWord document can define all the labels and transform functions that it uses, in other words it can define its own markup lingo. But most authors will employ a standard pre-defined library to provide a core markup language, a common lingo. This lingo can be bundled together with the MyWord translator. Documents can extend this core lingo with their own label and transform definitions.

Larger MyWord documents can include content from separate files by using an `[include] transform to read the content of a given URL. The lingo of the importing document is inherited by the imported document (i.e. the definitions are shared). Included documents may also include further documents.

For example:

.demo
    @include  MyWord.part.myw

    &  @include = <div class=include> include

The document with URL `[MyWord.part.myw] is translated as a MyWord file, and it inherits the lingo of the host document.

If the content of the URL is a self-contained HTML document then an HTML `[<iframe>] element should be used to imbed the extenal document. The `[@imbed] label works like the `[@include] label, but it will imbed an HTML document in complete isolatation from the host document.

In general a file read by the `[include] transform will be translated according to its file suffix. The file suffix (including the dot as a prefix sigil) will be treated as a markup label, just as if it was a block label on the content of the file. If the suffix is not defined as a label then the file will be translated as a myword file by default.

Here is the same file being read as plain text:

.demo
    @include  MyWord.part.myw

    &
      @include = <div class=include> include
      .myw = <pre> text

Of course the `[.myw] label is normally defined so that files with a `[.myw] suffix are translated as MyWord documents, and files with a `[.txt] suffix will be read as plain text files:

.eg
    &
        .myw = <div> myword
        .txt = <pre> text

Definitions of labels and transform functions are available inside included documents. Other definitions can be loaded from a separate file using the `[@import] instruction. As we saw in a previous example for AsciiMaths translation.

Third party translators that are available as a JavaScript function can be used too. For example, a document containing Markdown markup can be translated with the `[marked.js] translator. This script defines a `[marked] function:

.demo
    @include  example.md

    &
      @include = <div class=example> include
      @import 3rdparty/marked.js
      .md = <div class=md> marked

The `[@import] loads the Markdown translator as JavaScript from the file `[marked.js]. The `[.md] label is defined to use this translator. The `[import] transform sees the `[.md] label that matches the file suffix and translates the file as Markdown by using the `[marked] transform function. The `[@import] instruction can also be used to import a CSS style sheet from a file with a `[.css] suffix.


##  Translating MyWord Documents

A standard web browser reads text files with HTML markup, but MyWord markup must first be translated into HTML. This can result in two versions of the same document, one version of the document containing markup for authors to read, and another version that contains HTML markup for browsers to read.

A better approach is to empower the browser with a markup translator so that the browser can read the MyWord markup source file directly. This avoids the need to separately translate documents, and it eliminates the need for different versions of the same document. The word "empower" is used to avoid confusion, there is no requirement for any particular browser "extension" or "plugin" technology.

A standard browser can load an HTML page with JavaScript code, and that can empower the browser to read and translate documents written with MyWord markup. The core MyWord translator also needs a dictionary of label definitions for the vocabulary of the lingo that the author employs.

Here is an example of an HTML file that can empower the browser to read MyWord documents:

.eg
    <!DOCTYPE HTML>
    <html>
    <head>
        <meta lang=en charset="UTF-8">
        <script src='lib/x-markup.js'></script>
    <body>
        <script type=text/x-markup.myword src="index.myw"></script>
    </body>
    </html>

The `[lib/x-markup.js] script will load all the translator machinery and lingo definitions.

All the required resource files are collected together in a `[my-document/] directory:

.eg
    my-document/
        index.html
        index.myw
        lib/
            x-markup.js
            x-markup.mmk
            markit.js
            grit.js

The `[index.html] file is the initial root that contains the HTML shown previously.

The `[index.myw] file contains the MyWord document source text.

The `[lib/] directory contains all the MyWord translator machinery and the initial lingo markup definitions:

-   `[x-markup.js] is the script that empowers the browser (it loads the other files).

-   `[x-markup.mmk] contains the initial markup lingo definitions.

-   `[markit.js] is the core MyWord translator.

-   `[grit.js] is a grammar parser used by `[markit.js].

The author's MyWord document is in the `[index.myw] file. This file may include other files or link to other files. A web page often requires a collection of different files for content text, CSS style sheets, media files (such as images), and so on. A common convention is to name the initial root file `[index.html], and a similar convention is followed here for the initial root `[index.myw] MyWord file.

For a simple document the `[index.myw] file might contain the complete MyWord source text. In that case the `[index.html] file could refer directly to a MyWord document by name, say `[document.myw]:

.eg
    <!DOCTYPE HTML>
    <html>
    <head>
        <meta lang=en charset="UTF-8">
        <script src='lib/x-markup.js'></script>
    <body>
        <script type=text/x-markup.myword src="document.myw"></script>
    </body>
    </html>

Even simpler, the MyWord source text may be included directly in the content of the `[<script type=text/x-markup.myword>] element.

The author can directly edit the MyWord document(s) source text with any text editor. There is no requirement to "translate" or "build" or "make" any other files.

A `[my-document/] directory is a self contained package with minimal external requirements. It is built on a standard browser and HTML standards. The World Wide Web relies on these standards and their backward compatiblity. There are millions of old HTML web pages that work the same as they ever did, despite rapid evolution and huge advances in the latest browser and HTML standards.

MyWord documents published in a `[my-document/] directory like this can be expected to work the same way for decades into the future. All the translation code and the markup language definitions are preserved together with the author's work. Only standard browser features and HTML are required.

Longevity is not something that can be said for even the most sucessful and popular commercial products. There is no guarantee that any word processor, web page editor, or other computer software will preserve an author's work. Too many have already come and gone. Plain text source, and HTML standards are about the best guarantee available.


---  ...

&  --- = <hr/>

##  Appendix

The MyWord grammars are specified using Grit grammar language, the details for this can be found in @grit[The Grit Grammar Parser].

&   @grit = <a href='GritGrammarParser.html'>


###  Block Grammar

The block grammar matches only one level of indentation, since the syntax inside the content is determined by the definition of the label. The default is to apply the myword grammar, which allows a myword document to be nested inside a myword block. But in general a block label can define the content to be any other grammar.

The indentation of lines in the block is not part of the content text, it is part of the skeleton format for the block, and it will be deleted. The content grammar will not see the indentation.

The MyWord document block structure is defined by this grammar:

.eg
	myword	:= (blank / block/ line)*          :: elems
	block   := label (blank* offset line)+     :: block
	blank   :~ [ \\t]* (?: \\n | \\r\\n?)      :: blank
	line    :~ [^\\n\\r]* (?: \\n | \\r\\n?)?  :: line
	label   :~ (\\S*)                          :: string
	offset  :~ (\\t | [ ]{2,8})                :: string

The parser identifies block labels that are defined with the `[metamark] transform and evaluates their content first, before it renders the parse tree.

The parser also groups lines into paragraphs.


###  Prose Grammar

The prose grammar follows the same scheme as the block grammar, it delimits the content text, but it does not parse the content. This allows the label to define the grammar for the content text. Most labels will apply the prose grammar recursively to the nested content.

.eg
    prose   := (elem / text)*
    elem    := label content
    content := paren / square
    paren   := [(] (paren / notp)* [)]
    square  := [\[] (square / nots)* [\]]
	label	:~ [^\sa-zA-Z0-9()\[\]]+ [a-zA-Z0-9_-]*
	notp    :~ [^()]+
	nots    :~ [^\[\]]+
    text    :~ [\s\S]([^ \(\[]*\s+)* [\sa-zA-Z0-9()\[\]]*

This is a basic default prose grammar. Authors may substitute a different grammar for the content of their prose paragraphs.


###  Meta Markup Grammar

The metaword grammar is for the definition of labels and transforms.

.eg
   metaword   := (blank / labeldef / typedef / uses / comment / undefined)*
   labeldef   := word eq labelspec     :: label
   typedef    := word gritrule         :: type
   uses       := "@import"  block      :: uses
   comment    := "//" line nl?         :: nil
   undefined  := sp* word line         :: undefined
   blank      := sp* nl                :: nil
   block      := line insetline*       :: string
   gritrule   := colon block           :: string
   labelspec  := tag / word sp* tag?
   insetline  := sp* nl / sp+ line
   colon      :~ [ \t]+ :
   eq         :~ [ \t]+ = \s*
   tag        :~ [<][^>]*[>]
   line       :~ [^\\n\\r]*
   word       :~ \S+
   sp         :~ [ \t]
   nl         :~ \r \n? | \n

The `[@import] instruction imports the content of file(s) given a list of their URL(s), and translates the content as `[metaword].

&	@import pkgs/demo.mmk @import  3rdparty/Beautify/beautify.mmk
	@css pre.Undefined {background: yellow;}
