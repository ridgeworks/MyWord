###  Type `myword`

MyWord provides a hierarchy of predefined *types*; the top-level type is `myword` whose content consists of a sequence of notations as expressed in the following PEG (Parser Expression Grammar) rule:
eg
	myword := (metablock / insetblock / labeledblock / blankline / paragraph)*
A `metablock` is a `labeledblock` with a predefined label `&` and content of *type* `metamark` which is used to define *notation*s and *type*s which determine how the other `myword` content is interpreted. The position of the `metablock` in the `myword` content doesn't matter, because they are processed before the other content, enabling any meta-definitions to apply anywhere in the rest of the content. `metamark` will be covered in detail in a later section, but will be introduced as required in examples of block and inline notations.

####  Type `insetblock`

An inset block is a sequence of one or more indented lines. An indented line begins with a tab character or exactly four spaces. This indent will be removed in constructing the block's content.  The default transform for `insetblock` generates a code block (for Markdown compatability) as expressed in the following `metamark` type defintion:
eg
	insetblock  :: (content) => `<pre><code class=my_text>${markit('text', content)}</code><pre>`

A type defintion uses the `::` operator to associate the *type* name, in this case `insetblock` with a JavaScript function which takes the content as a parameter and returns the rendered result. The `markit` function called in the template string is just a global function available to transforms to call other transform functions by specifying their type name, in this case `text`. Here's an example:
demo
	The following is a `insetblock` whose default transform
	renders it as a code block:
		// sample JavaScript ...

		const greet = (who) =>
			console.log(`Hello ${who}!`)

		greet("World") // Hello World!
	etc.
The "demo" source (the left hand side) in the example above is editable, so feel free to change it and see how that effects the rendered output. These changes aren't saved anywhere so you can't do any permanent damage. (All demos in this guide are editable so if you don't understand something from the explanatory text, experiment with the source to see if that helps.)

####  Type `labeledblock`

The first line of a `labeledblock` starts with a word corresponding to a *label* defined in a `metablock`. A *label* can be any sequence of non-whitespace characters. The content starts after any whitespace following the label to the end-of-line, as well as any content in an immediately following `insetblock`. If the line starting with the label is otherwise empty (i.e., just whitespace), the content will just be the content of the `insetblock`. If it is not followed by an `insetblock`, the `labelledblock` has no content.

The default transform for `labeledblock` is:
eg
	labeledblock  :: (content, labelPattern) => markit.applyLabel(labelPattern, content, 'myword')

`markit.applyLabel` is another global function that can use `metamark` notation definitions (see below) to transform content. If the notation definition doesn't specify a type (see below), `myword` (third argument) is the default type.

Here's an example which defines and uses `labeledblock`'s for headers and list items:
.myw
	demo
		#### A Section Header
		This section is just a list:
		* Item 1
		* Item 2
			continued...
		* Last item.
		&
			#### .. <- <h4> myword
			* ..    <- <div class=my_listitem> myword
			@css  div.my_listitem {display:list-item; margin-left:40px}

Notation definitions in `metamark` use the '`<-`' operator. The general form of a notation definition is:
eg
	labelPattern <- wrapper typeSpec
where
*  `labelPattern` is the "name" of the notation. For `block` notation definitions, the label pattern consists of the label followed by a space and two periods, e.g., `#### ..`. Other kinds of notations notations will use different label patterns.
*  `wrapper` is optional, but if present, is an HTML begin tag to be used to wrap the rendered HTML content for the notation. 
*  `typeSpec` is used to lookup the transform to use for rendering any content from the notation. In the examples so far, the `typeSpec` is just the name of a type.  The `typeSpec` is also optional; if absent the default type is `myword` for `block` notation definitions. So the notation definitions in the example could be just written as '`#### .. <- <h4>`' and '`* ..    <- <div class=my_listitem>`'.

The `@css` statement in *metamark* is used to define scoped style rules. They are typically used to affect the presentation of the HTML elements generated by the notation definitions; in this case for `div.my_listitem` generated by the `* ..` notation.

Here's the JavaScript example seen earlier using a custom `labeledblock` rather than a code block. This demo also illustrates the use of the `@import` statement in `metamark` to use defintions in external `metamark` files, in this case the `.gv` label for GraphViz content.
demo
	.js	// sample JavaScript ...
		
		const greet = (who) =>
			console.log(`Hello ${who}!`)
		
		greet("World") // Hello World!
		
	A *GraphViz* graph:
	.gv
		digraph G { A -> B -> C; A -> C; }
	
	&	.js .. <- <pre class='js'> text
		@css .js {background:lemonchiffon;}
		@import 3rdparty/GraphViz/gv.mmk

The `& metablock` defines a block level notation (`.js ..)` which treats the content as plain text (type `text`) and wraps in the HTML element `<pre class='js'>`, i.e., the content is pre-formatted. A CSS rule is also specified for the class `js` to give it a distinctive background.

The meta-defintions for for the block label `.gv` are imported from the external file `3rdparty/GraphViz/gv.mmk` which contains `metamark` content; such files are called *package*s. `.gv` blocks contain content of type `gv` (as defined inside `gv.mmk`) which is content written in the 'dot' language as specified by [GraphViz].

aside> Aside: The default transform for type `metamark` returns the empty string so `metablock`s do not appear in the rendered output. User defined transforms can render the `metamark` content but they can't affect the "meta-content" used by the MyWord parsers.

Although the choice of `labeledblock` labels is unconstrained, words that could naturally occur at the beginning of normal text should be avoided. The easiest way around this is to adapt a prefix convention using a rarely used symbol character, eg., '`!`', '`$`', or '`^`' as in `!section` or `$demo` or `^table`. And any line that begins with a space will never be interpreted as a label.

####  Type `blankline`

The syntax of `blankline` is pretty simple; it's a line containing only whitespace characters (spaces or tabs) that doesnt start with an insert (one tab or four spaces) followed by a newline. `blankline`s are used to explicitly control vertical spacing between the other `myword` notaions and has the default transform:
eg
	blankline  :: (_) => '<div class=my_blank>&nbsp;</div>'
Users can override this type defintion or use CSS rules to modify vertical spacing behaviour.

When one or more `blankline`s are preceeded and succeeded by indented lines, the `blankline` is part of the containing indented block and the meaning of the `blankline` is determined by the type of the block's content. `blankline`s cannot be used to separate indented blocks.

####  Type `paragraph`

What's left of the `myword` content are instances of type `paragraph`. So a paragraph is just a sequence of non-blank lines which don't start with a defined label or an indent. The default transform for a paragraph is:
eg
	paragraph  :: (content) => `<p class=my_p>${markit('prose', content)}</p>`
	
`paragraph` content will be rendered as type `prose` and wrapped in a `<p>` element; the `prose` type is documented in the next section. The wrapper also has a class attribute, `my_p`, to enable CSS rules to be applied to `paragraph` notations.

<#TableOfContents>


&	[Graphviz] <- link http://graphviz.org/