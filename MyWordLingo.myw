#   MyWord Lingo

In MyWord a lingo is a vocabulary of markup labels and transform functions. A small core vocabulary is all that is required to publish many small documents, but a larger vocabulary may be needed for a book or a web-site. In addition some topics, such as mathematics, may need their own special lingo.

Individual documents can define their own custom lingo, but a lingo from a library of definitions can be shared across many documents. This document describes a core lingo for simple documents. A library of additional feature packages can be used to extend the core lingo, and to add other special purpose lingos.

##  Label Semantics

It is generally a good idea for a markup label to have a semantic meaning without regard to its presentation. A label should have the same meaning as the HTML element that the label represents. The presentation can be defined with separate CSS style rules.

Each markup label should have one and only one semantic meaning, the same as HTML tags names. In MyWord a label can be used for a block element, or for an inline element in prose content. Most HTML elements are either a block element or an inline element, but not both. It follows that a label will usually only represent a block element or an inline element.

Popular light-weight markup languages break this rule and give some symbols more than one meaning. For example a star * may be used for both a bullet point and to quote a phrase of text for emphasis. In English it is common for a word to have more than one meaning, and this practice seems to have continued into markup symbols.

Nice shorthand symbols are in short supply, so it is understandable that they may be given different meanings in a different contexts. On the other hand it would be unreasonable to define more than one semantic meaning for any given HTML tag name. MyWord can employ a rich variety of labels, so the core MyWord lingo defines only one semantic meaning for any given label. It follows that most labels will only make sense as either a block element or as an inline element.

Remember that an author can always define a local meaning for any label, so the core lingo can be extended and over-ridden in any way the author desires.


##  Simple Documents

Even a small lingo can be very useful. This is demonstrated by many light-weight markup languages, such as Markdown, that have become popular and widely used. The core MyWord lingo aims to provide equivalent capabilities.

The core features include:

-   Headers.

-   Prose elements (bold, italics, etc).

-   HTML links and images.

-   Plain text for code and data.

-   Lists.

-   Tables.

-   Custom HTML.

This small set of features is sufficient for many documents, and extra needs can use custom HTML extensions.

Light-weight markup languages such as Markdown define an easy to read notation for each of these features, but they fall back to standard HTML annotations for anything beyond the built-in features.

MyWord is different. There are no built-in features, any markup label can be defined to represent any feature. This means that there is no need to fall back to standard HTML annotations, the author can define a new label to represent any require HTML element.

The next sections will show how an author can define MyWord labels for each of the core features. Defintions like these are collected together into a vocabulary that defines a lingo for the core features.


###   Headers

First, labels may be defined to directly represent the corresponding HTML element:

.demo
    :h2  Header 2

    :h3  Header 3

    &
        :h2 = <h2>
        :h3 = <h3>

The HTML headers :h1 to :h6 can all be befined the same way.

A header has `[prose] content, without nested blocks.

Labels can also be defined to mimic the Markdown notations:

.demo
    ##  Header 2

    ###  Header 3

    &
        ##  = <h2>
        ### = <h3>

The header text is usually a single short line, but a block label can have multiple indented lines of content:

.demo
    ####
        A Silly Long Header
        That Keeps On Going

A more elaborate header defintion could include the header text as an ID to enable HTML links to refer to it:

.demo
    ###  Some Topic

    &
        ###  = header3
        header3 :: (content) =>
            "<h3 id='"+markit('text',content)+"'>"+
                markit('prose',content)+"</h3>"

Style rules can present headers in different ways, for example with a border line to divide sections.

A simple horizontal rule may also be used:

.demo
    ---  ...

    &    --- = <hr/>

An empty element has no content, but a markup label with an empty content block is not seen as an offset label, so some content is needed. The content of an empty label is not presented, it can be used for comments.


###   Prose Elements

The inline HTML elements for emphasis and related tags can be defined directly like this:

.demo
    :i[italic]

    :b[bold text]

    :em[emphasis]

    :strong[strong emphasis]

    :cite[Alice In Wonderland]

    &
        :i = <i>
        :b = <b>
        :em = <em>
        :strong = <strong>
        :cite = <cite>

Many similar HTML tags can be defined in the same way, from now on we will assume that a label like `[:tag] will be defined to represent the same name HTML element `[<tag>].

Symbols similar to Markdown can be defined as labels too:

.demo
    *[emphasis]

    **[strong emphasis]

    &
        * = <em>
        ** = <strong>

Of course there is no reason why these labels could not be defined to be italics and bold instead. The * is also a good choice for a bullet point, but to avoid ambiguity it will not be used for that purpose here, a dash - will be used for bullet point list items.

The bracket notation avoids many of the complications that occur in the Markdown quote style notations.

For example, consider:

.demo
    *[Some x*y **[thing]]

&
    * = <i>
    ** = <b>

Other prose elements:

.demo
    >
        Blockquote ...

        ~[underline]

        this^[superscript]

        that_[subscript]

        ~~[strike out]

        ?[mark this]

        //  and more...

    &
        > = <blockquote> myword
        ~ = <u>
        ^ = <sup>
        _ = <sub>
        ~~ = <s>
        ? = <mark>
        // = <span hidden>

    :style
        blockquote {
            border-left: 5pt solid whitesmoke;
            padding-left:10pt; }

###   Links

A URL can be translated into an HTML link, which is one of the few HTML elements that can be either a block or an inline element:

.demo
    @   http://csszengarden.com

    @[http://csszengarden.com]

    &
        @ = linkURL

        linkURL :: (content) => {
            var url = markit('text', content);
            return "<a href='"+url+"'>"+url+"</a>";
          }

&
    linkURL :: (content) => {
        var url = markit('text', content);
        return "<a href='"+url+"'>"+url+"</a>";
      }

In general custom defined links need to be defined directly:

.demo
    @zen[CSS Zen Garden]

    &   @zen = <a href='http://csszengarden.com'>

Internal links can be used for cross references:

.demo
    See @id[foo] ...

    #id[foo]: All about foo ...

    &
        @id = linkID
        #id = <b> isID

        linkID :: (content) => {
            var id = markit('text', content);
            return "<a href='#"+id+"'>"+id+"</a>";
          }

        isID :: (content) => {
            var id = markit('text', content);
            return "<span id='"+id+"'>"+id+"</span>";
          }

&
    linkID :: (content) => {
        var id = markit('text', content);
        return "<a href='#"+id+"'>"+id+"</a>";
      }

    isID :: (content) => {
        var id = markit('text', content);
        return "<span id='"+id+"'>"+id+"</span>";
      }


###   Images

An image URL label ! can be defined similarly:

.demo
    ![images/gopher.png]

    &   ! = image
        image :: (content) =>
          "<img src='"+content+"'/>"

Images can also be defined directly:

.demo
    !go[]

    &   !go = <img src='images/gopher.png' title='GO gopher'/>


###   Plain Text

There are various HTML tags for plain text:

.demo
    :pre
        A block    of
            preformatted
        :code[code or data]

    :code[code or data]

    :kbd[keyboard text]

    &
        :pre = <pre> text
        :code = <code> text
        :kbd = <kbd> text

Plain text content for code or data should be presented verbatim, including any nested markup. The `[text] transform does this. In HTML itself there is no equivent way to quote text verbatim.

The shorthand symbols / can be used for a :pre element, and ` for a :code element:

.demo
    /   A preformatted   block
        of        `[code or data]

    `[some :code[code or data] text]

    &
        / = <pre> text
        ` = <code> text

Syntax highlighting can be added:

.demo
    A snippet of Python code:

	.py
		# this a blob of Python code
		if x > 42:
			print 'end of </script>.'

    &   .py = <pre class=py> highlight

The `[.py] label applies the `[highlight] translator to its content, and wraps the result into an HTML `[<pre>] element. The `[highlight] function translates the content text into HTML element for the Python syntax which enables style sheet rules to present the syntax highlighting.

The // label can be used for comments:

.demo
    //  This is a comment ...

    &  // = <div hidden>


###   Lists

HTML list tags can be used directly:

.demo
    :ul
        :li  An unordered list item.
        :li  Another list item.

    :ol
        :li  An ordered list item.
        :li  Another list item.

&
    :ul = <ul> myword
    :li = <li> myword
    :ol = <ol> myword

A quick and easy way to write lists is provided by defining labels that use a list transform function:


.demo
    -   Unordered list item.
    -   Another list item.

    +   Ordered list item.
    +   Another list item.

    &
        - = <ul> list
        + = <ol> list

The `[list] transform groups elements with the same label together as list item elements inside the given HTML list wrapper.


####  Defintion Lists

The third form of HTML lists is for defintions:

.demo
    :dl
        :dt  A Term
        :dd  The defintion of a term ...

        :dt  Another Term
        :dd  Another defintion ...

&
    :dl = <dl> myword
    :dt = <dt> text
    :dd = <dd> myword

A simpler way to write a list of defintions is to use the `[deflist] transform that enables the layout of the content text to directly represent terms and their defintions. The defintions are simply indented further than the term.

The `[deflist] transform also defines an ID attribute for the term line. This allows links to reference terms via a `[deflink] transform:

.demo
    See @notes[Flim] or @notes[Flam].

    ####  Notes:

    .notes

        Flim

            A note about flim...

        Flam

            A note about flam...

    &
        @notes = deflink
        .notes = <dl class=notes> deflist

&
    deflink :: (content) => {
        var key = markit('text',content)
        var id = key.replace(' ','_')
        return "<a href='#def-"+id+"'>"+key+"</a>";
      }

    deflist := (blank / key / val)* :: (x) => this.flatten(x).join('')
        key :~ (?: [ ]? [^ \t\n\r])+ :: (dt) =>  {
            var key = markit('text',dt)
            var id = key.replace(' ','_')
            return "<dt id='def-"+id+"'>"+key+"</dt>"
        }
        val :~ (?: (?: [\t]|[ ]{2,8}) [^\n\r]+ %blank*)+ :: (val) =>
            "<dd>"+markit('myword',val)+"</dd>"
        blank :~ [ \t]* (?: \n | \r\n?) :: () => ''

Definition lists can be used like this for a glossary of terms, or a bibliography, or end notes, and so on.


###   Tables

Tables can be written using standard HTML table elements. This provides full flexibility, but it is rather verbose:

.demo
    :table
        :tr
            :th  Unit
            :th  Shape
            :th  Dimension
        :tr
            :td  1
            :td  line
            :td  length
        :tr
            :td  2
            :td  plane
            :td  area
        :tr
            :td  3
            :td  space
            :td  volume

&
    :table = <table> myword
    :tr = <tr> myword
    :th = <th> myword
    :td = <td> myword

:style
    th, td { padding-left: 10pt; }

A simple array format can be used to directly represent a small table. In an array format each line represents a row, and cells are separated by one or more tab characters, or two or more space characters:

.demo
    .array
        1    line     length
        2    plane    area
        3    space    volume

    &  .array = <table class=array> array

:style
    table.array {border-collapse:collapse;}
    .array td { border:thin solid gray; padding:2pt 10pt; }
&
    array := row*                 :: (rows) => this.flatten(rows).join('')
        row   := tsep* cell* nl?  :: (_,cells) => (cells.length>0)? ["<tr>",cells,"</tr>"] : ''
        cell  := item tsep?       :: (item) => ["<td>",markit('prose',this.flatten(item).join('')),"</td>"]
        item  := (!delim char)+
        delim :~ %tsep | %nl
        tsep  :~ ([ ]*[\t]|[ ]{2,}) [ \t]*
        nl    :~ [\n\f]|([\r][\n]?)
        char  :~ [\s\S]

The `[array] transform is defined in the core lingo, so authors may define custom tables with their own style:

.demo

  .lunch
    Name    Lunch order   Spicy     Owes
    Joan    saag paneer   medium    $11
    Sally   vindaloo      .g(mild)  $14
    Erin    lamb madras   .r(hot)   $5

  &
    .lunch = <table class=lunch> array
    .g = <span style='color:green;'>
    .r = <span style='color:red;'>

  :style
    table.lunch {border-collapse:collapse;}
    .lunch td { border:thin solid gray; padding:2pt 10pt; }
    .lunch tr:nth-child(1)  { font-weight:bold; background:whitesmoke; }
    .lunch td:nth-child(4)  { text-align:right; }



###  Custom HTML

MyWord will escape any HTML syntax characters so that the source text is presented verbatim. However, the author may choose to define an `[:html] label to represent a feature that can present HTML. This `[:html] label will not translate its content text so that any standard HTML annotations will be presented as HTML elements.

.demo
    :html
        <h3>Header <i>three</i></h3>

    &   :html = rawText
        rawText :: (txt) => txt

##  Conclusion

This document outlines features that will cover many simple documents. These features are defined with labels and transform functions that create a core lingo. Authors can change or extend this lingo as they need.

Other lingos can be defined for particular applications, such as maths notations, and these lingos can be loaded as separate feature packages on top of the core lingo.



