#    MyWord Markup

The essence of any markup language is to enable an author to *[label] pieces of text to explain the intended meaning. In MyWord the authors can define their own markup labels, and embed any kind of markup language or notation. The markup labels can be defined by the author to be easy to understand with minimum distraction for the reader.

MyWord enables the first word in a line to be used as a markup label for a block of text. Blocks of text without a markup label are paragraphs of prose by default. In prose pragraphs markup labels can be applied to text in brackets.

Here is an example with a couple of MyWord markup labels. The `[##] symbol is used here to label a header, and the `[*] symbol is used for emphasis:

.demo
  ##  A Header Line

  The *[Alice In Wonderland] story.

On the left is the plain text source using MyWord markup, and on the right is an HTML presentation generated from the MyWord markup.

Symbolic labels are neat and simple, but they are only practical for a small vocabulary. For a larger vocabulary key-word labels are a more effective way to express the intended meaning. An author may choose to use tag words that are defined in the HTML standard as part of their vocabulary of labels.

The next example uses the standard HTML `[h2] tag for a header, and the HTML `[cite] tag for a citation. A colon prefix is used by convention to indicate that these labels are HTML tag names:

.demo
	:h2  A Header Line

	The :cite[Alice In Wonderland] story.

In MyWord a block markup label is any first word that is offset from the following text by a tab or two or more spaces. The content of a block label is the remainder of the line plus any lines that are indented under the label line (by a tab or two or more spaces).

Lines of text that do not start with an offset label form paragraphs of prose which may contain inline markup. An inline label uses brackets to delimit the content text.

MyWord does not pre-define any markup labels, but the MyWord translator is normally packaged with a vocabulary of common labels, known as a lingo. Authors can also define their own markup labels, and any undefined labels will be flagged in the HTML presentation.


##	Label Vocabulary

Simple documents only require a small set of common labels for: headings, italics, bold, lists, and a few other things.  These are the features provided in light-weight markup languages such as Markdown. They are also the basic features of a WYSIWYG (What You See Is What You Get) editor, as used for emails or blog notes and the like. A MyWord translator can be packaged together with a vocabulary of labels to meet these needs.

Standard HTML tag names can be used:

.demo
	HTML tags for :i(italic), :b(bold) and :u(underline).

	For more semantic meaning :em(emphasis) or :strong(bold words).

	Keyboard :kbd(mono font) and :code(a = b+c;)

	Hit the :button[return] key.

Shorthand symbols such can be used for common labels:

.demo
	##  Level 2 Header
	###  Level 3 Header
	####    Level 4 Header

	Shorthand symbols: *(emphasis), **(bold words), and `(plain text).

	Superscript^(above) and subscript_(below).

	>   An HTML blockquote tag presents text that
		is indented from the margin.

&
	* = <em>
	** = <strong>
	` = <code>

Shorthand symbols can also be used for HTML lists and links:

.demo
	-   Bullet point list.
	-   Second bullet point.
		+   First numbered point.
		+   Second numbered point.
	-   Third bullet point.

	A web address URL link: @[http://csszengarden.com].


##  Label Definitions

Markup labels are not pre-defined by the MyWord translator, any label can be defined to represent any HTML element.

Here is a sample of a few of the definitions for labels seen in previous examples:

.eg
	&
		:h2 = <h2>
		:h3 = <h3>

		:i = <i>
		:b = <b>
		:cite = <cite>

		*  = <em>
		** = <strong>
		`  = <code>

		> = <blockquote> myword

The special & label introduces a block of definitions. Each label is defined with the HTML element that it represent.

Rather than write a block of definitions like this into every document an author can put them into a file that can be shared across many documents. A file of definitions can be used like this:

.eg
	&   @import  myWord.definitions.txt

The `[@import] takes a URL for a file containing definitions of the vocabulary of labels that the author wants to use.

The MyWord translator is normally pre-packaged with a default vocabulary of label definitions (known as a lingo). The author can add custom labels to extend or over-ride this vocabulary.


##	Custom Label Definitions

A shared file of definitions can provide a rich vocabulary of labels, but a document can also define its own custom labels.

For example the `[.box] label could represent an HTML `[<div class='box'>] element. It is a common convention to use a dot prefix to indicate an HTML class attribute:

.demo
	.box    A box of *[prose]...

	&   .box = <div class='box'>

Inline markup labels can be defined in a similar way:

.demo
	The story by .author[Lewis Carroll].

	&   .author = <span class=author style="color:firebrick">

The label for an HTML link element is defined here with a `[@] prefix to indicate that it represents a link:

.demo
	See the @zen[CSS Zen Garden] web site.

	&   @zen = <a href='http://www.csszengarden.com'>

An image uses the HTML `[<img>] element which has no content, the label has been given a `[!] prefix to indicate an image:

.demo
	!go[]

	&   !go = <img src='images/gopher.png' title='gopher'/>

A footnote or end-note can be created from HTML components like this:

.demo
	The temperature above absolute^nb[Kelvin] zero.

	#nb  Notes

		Kelvin: Absolute zero is 0Â°K ....

	&
		#nb = <div class='nb' id='nb'>
		^nb  = <a class='nb' href='#nb'>

The `[#nb] label is a block label that is defined with the target ID `[nb]. The `[^nb] label is defined as an HTML link to the target. The style sheet has presented this example in the form of a footnote.


##  Plain Text Content

The previous examples defined MyWord labels to represent different HTML elements. The content text is usually translated as MyWord markup, so markup labels may contain nested labels. Just as the content of an HTML element can contain nested HTML elements.

Sometimes an author may want to quote the content text verbatim, without any translation. An author can do this with a label that uses a plain text translation, so that the content can be presented verbatim:

.demo
	Here is: `kbd[keyboard *[literal] text].

	&   `kbd = <kbd> text

The `[`kbd] label specifies a `[text] translation for the content text that will then be wrapped into a `[<kbd>] element. This means that any markup notations in the content text will not be translated, the source text will be quoted as literal text.

Plain text translated verbatim may be presented with syntax highlighting:

.demo
	A snippet of Python code:

	.py
		# this is a blob of Python code
		if x > 42:
			print 'end of </script>.'

	&   .py = <pre class=py> highlight

The `[.py] label applies the `[highlight] translator to its content, and wraps the result into an HTML `[<pre>] element. The `[highlight] function translates the content text into HTML element for the Python syntax which enables style sheet rules to present the syntax highlighting.

The `[text] and `[highlight] translators preserve the content text and present it verbatim, but other translator functions can transform the content in different ways.

##  Content Translation

A label can be defined to translate its content text. This enables an author to use custom notations and formats.

For example, the source text layout format can be used to directly represent an array of elements in an HTML table. In an array format each line is a table row, and column fields are simply separated by white-space, either tabs or multiple space characters:

.demo
	.array
		1    One      Line
		2    Two      Area
		3    Three    Volume

	&  .array = <table class=array> array

:style
	table.array {border-collapse:collapse;}
	.array td { border:thin solid gray; padding:2pt 10pt; }

&
	array := row*                 :: (rows) => this.flatten(rows).join('')
		row   := tsep* cell* nl?  :: (_,cell) => ["<tr>",cell,"</tr>"]
		cell  := item tsep?       :: (item) => ["<td>",this.flatten(item).join('').replace(/</g,'&lt;'),"</td>"]
		item  := (!delim char)+
		delim :~ %tsep | %nl
		tsep  :~ ([ ]*[\t]|[ ]{2,}) [ \t]*
		nl    :~ [\n\f]|([\r][\n]?)
		char  :~ [\s\S]

The label definition specifies that the array transform function is to be applied to the content text. This function translates the array of source text fields into cells in an HTML table element.

The definition of transform functions is discussed in the next section. For the moment let's just assume that transform functions like this are available.

A label can use a transform function to parse any source text syntax.

Here is another example, for a month/day/year date format:

.demo
	It starts on .mdy[2/3/2013].

	&   .mdy = <b class=date> mdy

&
	mdy  :~  (\d{1,2})\/(\d{1,2})\/(\d{4}) :: (_,m,d,y) => {
		var dd = (d.length < 2)? '0'+d : d;
		var mm = (m.length < 2)? '0'+m : m;
		var ymd = y+'-'+mm+'-'+dd;
		return '<time datetime="'+ymd+'">' +
			(['Jan','Feb','Mar','Apr','May','Jun',
			'Jul','Aug','Sep','Oct','Nov','Dec'][m-1]) +
			' ' + d + ', ' + y + '</time>'; }

The content of the .mdy label is translated from a month/day/year format using the "mdy" transform function, and the result is wrapped into an HTML <b> element.

An HTML link element requires a URL as an `[href] attribute value, so defining a label to represent an HTML link requires a transform function:

.demo
	@[http://csszengarden.com]

	&   @ = linkURL

The `[linkURL] transform function generates the required HTML wrapper: `[<a href='http://csszengarden.com'>] .

A label for a list item can be defined by a transform that will compose a group of items into an HTML list:

.demo
	-  First bullet point...

	-  Second point...

	  +  First step in the second point.
	  +  Second step..
	  +  Third step.

	-  Third point.

	&   - = <ul> list
	&   + = <ol> list

The `[list] transform wraps each item into an HTML `[<li>] list element, and then wraps a group of adjacent list items inside an HTML `[<ul>] or `[<ol>] list element.

The `[math:] label can be defined with an `[asciimath] transform function that will translate AsciiMath notation into HTML Math ML elements. This label and transform are defined in a separate file that can be imported and used like this:

.demo
	math:
        sum_(i=1)^n i^3=((n(n+1))/2)^2

	&   @import pkgs/asciimath.mmk

An author may wish to break a document up into parts to be edited as separate files. Separate parts can then be included into the main document body with an `[@include] label:

.demo
	@include  MyWord.part.myw

	&	@include = <div class='include'> include

	:style
		.include { border:solid thin grey; }

The `[@include] label is defined in the same way as any other label, it uses the `[include] transform function to import the content text from a URL for a file. The content of that file is read and translated into HTML according to the file name suffix. A `[.myw] file is translated as text with MyWord markup.


##  Transform Functions

The previous examples showed how labels can be defined with transfom functions. New transforms can be defined in MyWord with grammar rules, or directly in JavaScript. This section illustrates how this is done, but most authors will not need know any of this unless they wish to extend MyWord with their own custom transform functions.

For example, a `[~greet] markup label could be defined with a custom `[hello] transform function:

.demo
	The standard ~greet[World] example.

	&
		~greet = <b style='color:magenta'> hello

		hello :: (content) => "Hello "+content

The `[hello] function is defined to simply add a "Hello " prefix to the content text.

The next example defines a `[tempF] translator functions to translate Celsius to Fahrenheit:

.demo
	It was .temp[42C] today.

	&   .temp = <span class=temp> tempF

		tempF :~  ([+-]?\d+)\s*([CF]) :: (_,val,unit) =>

			((unit == 'C') ? Math.round((val*9/5+32)*10)/10 : val)+"ÂºF"

The `[.temp] label is defined with a `[tempF] transform function. The `[tempF] transform is defined using the `[:~] symbol which introduces a regular expression rule to match the content text. The `[::] symbol introduces a semantic action that translates the matched text for the HTML presentation. The details do not matter, this example is just to illustrate how new custom markup translators can be defined. The details are explained in a separate document.

The next example defines the `[mdy] transform function for a month/day/year date translation:

.demo
	The date was .date[2/3/2013].

	&

		.date = <span class=date> mdy

		mdy  :~  (\d{1,2})\/(\d{1,2})\/(\d{4}) :: (_,m,d,y) => {
			var dd = (d.length < 2)? '0'+d : d;
			var mm = (m.length < 2)? '0'+m : m;
			var ymd = y+'-'+mm+'-'+dd;
			return '<time datetime="'+ymd+'">' +
			(['Jan','Feb','Mar','Apr','May','Jun',
			'Jul','Aug','Sep','Oct','Nov','Dec'][m-1]) +
			' ' + d + ', ' + y + '</time>'; }


If labels and transform functions like this are defined in a separate file they can be shared across different documents, so that the author does not need to have these definitions in the source text.

Third party markup translators, or domain specific language translators, may also be used to transform blocks of text in MyWord documents. The MyWord block labels do not impose any restrictions on the content text, there is no requirement to escape any special syntax characters. An author is free to employ any special purpose language as a translator.

Authors can select labels and transforms that suit their needs from a library of definition files. With a little programmaing knowledge it is simple and fun to define new custom transforms. The details of this are discussed in a separate document.


##  Wrapping It All Up

A MyWord document can be translated into HTML on a server, or in a browser.

One interesting way to deliver MyWord source text is inside an HTML script element. The `[x-markup.js] script in an HTML page will translate the contents of a `[<script type=text/x-markup.myword>] element into HTML.

The MyWord source text in a `[<script>] element could be a complete MyWord document that defines its own labels. But any MyWord source file can import other MyWord source files and label definitions. The source text and the label definitions can therefore be divided into separate files in any way the author wants.

The result is a small HTML "host" file that enables a standard browser to read and translate MyWord files. This allows the MyWord source text to be edited without the need to translate it into an HTML file, since the browser can read and translate the source text directly.

This HTML host file will import the `[MyWord.example.txt] file that contains the MyWord source text, and that can import any definition files that it needs:

.eg
	<!DOCTYPE HTML>
	<html>
	<head>
		<meta lang=en charset="UTF-8">
		<title>Example MyWord</title>
		<script src='x-markup.js'></script>
	</head>
	<body>
	<script type=text/x-markup.myword>
	@include  MyWord.example.txt
	</script>
	</body>
	</html>

The `[x-markup.js] script is packaged in a directory with other resources. This script will automatically load any other resources that it needs from this directory. See the ReadMe document for more specific release information.

##	Conclusion

MyWord has no predefined markup labels, authors can define a vocabulary of labels to suit their language preferences and the needs of their documents. Any MyWord label can be defined to represent any HTML element the author requires.

MyWord makes it very easy to define new markup labels that may contain any desired data formats or domain specific languages.

:style
	*.box {border:thin solid gray; background:lavenderblush; margin:0pt 10pt; padding: 0pt 10pt;}

	div.nb { font-size: small; border-top: solid thin grey; }
	a.nb { vertical-align:super; font-size: x-small;}
