##.  Implementing Document Features for MyWord
MyWord provides a flexible translation system for converting annotated text to HTML. But many useful features can't be done with only a translator. One example is a table of contents generator which needs to collect heading information from the entire document. Another example is an extension of the `(.demo) notation used in the MyWord documentation (e.g., @intro(MyWord Markup)) which permits a user to dynamically edit the contents. 

One way of implementing such features is by using custom elements (introduced in HTML5; see @custom(Custom Elements)). MyWord labels can be easily defined to generate custom elements, and semantics can be added to those custom elements using JavaScript to access the full power of the environment. Both the label definitions and the associated JavaScript code can be collected into a single metamark package file which is then `(@import)ed by the source document. The remainder of this application note covers a number of examples of document level features that can be implemented in this way.

###.  Example 1: Content Substitution
Consider a boiler-plate style document that has a number of *(variable) references, e.g., a contract date or an author. Elsewhere in the document is a definitions list containing the *(values) to be substituted for the corresponding references.

For this example, the label `(%) will be used to identify references, e.g., `(%(version)). The content of the reference is the variable name, which will be associated with a value in a definitions list somewhere else in the document. A simple example:
.demo
	%(version) was released on *(%(release-date)). 

	A %(missing) definition.
	
	%define
		version		:b(v0.1)
		release-date	September 3, 2016

	&  @import pkgs/defines.mmk
	   @css myword-def {font-size:smaller}

By default, if no definition is provided, a reference will be marked to identify possible problems. Here's the label definition for `(%):
.eg
	% = var_ref

	var_ref :: (content) => {
            var ref = markit('text',content)
            return ['<myword-ref name="', ref, '"><mark>%', ref, '</mark></myword-ref>'].join('')
           }
Note that the reference will be contained in a `(myword-ref) custom element with a `(name) attribute value set to the name of the variable.

Definitions will put in a `(%define) block using the `(deflist) transform provided by the @lingo(Core Lingo):
.eg
	%define = defineslist <myword-def>

	defineslist :: (content) => 
		['<dl class=var_define>', markit('deflist', content), '</dl>'].join('')
A defines list is contained in a custom `(myword-def) element containing a `(dl.var_define) (using CSS selector syntax).

The translation of MyWord content using these definitions will generate the necessary custom elements for references and definitions, but will not perform any content substitution. This requires adding semantic meaning to `(myword-def) elements. When a `(myword-def) gets added to the document, all the definitions should be used to scan for corresponding references. Their content is then replaced by the definition content. The code to accomplish this is:
.eg
  class MyWordDef extends HTMLElement {
    constructor() { super(); } 
    connectedCallback() {
      var defs = this.firstChild.children               // <myword-def><dl>...
      var var_name, var_value, var_p, refs
      for (var def=0; def < defs.length; def++) {  // defs.length is even number for <dt><dd> pairs
        var_name = defs[def].innerText      // name is innerText of <dt>
        var_value = defs[++def].innerHTML   // value is innerHTML of <dd>
        refs = document.body.querySelectorAll('myword-ref[name="' + var_name + '"]')
        for (var r = 0; r < refs.length; r++) {
          refs[r].innerHTML = var_value
        } // for
      } // for
    } // connectedCallback()
  } // MyWordDef

  customElements.define('myword-def', MyWordDef)
The call to `(customElements.define) associates the `(MyWordDef) class with the custom tag `(myword-def). Whenever an instance of a `(myword-def) element is added to the DOM, the `(connectedCallback) method will be called. This method will scan the document for `(myword-ref)'s corresponding to its definitions, and substitute the associated value for the current content.

The JavaScript and the label definitions can be combined in a single `(metamark) package file, as provided in the `(pkgs/defines.mmk) - see Appendix A for a source listing. 

###.  Example 2: A Simple Table of Contents
For this example, a "Table of Contents" is defined as a table of links to "headings" in the document. "headings" are `(<h1>..<h6>) elements with the custom attribute `(data-myword-toc). The actual table of contents will be an instance of the custom element `(myword-toc). This element has two optional attributes, `(min-level) and `(max-level), specifying the range of headings to be placed in the table of contents. For example, `(<myword-toc min-level=1 max-level=4>) will generate a table of links to elements between `(<h1>) and `(<h4>). The default range is `(min-level=1) to `(max-level=6).

The label definitions required for this "Table of Contents" feature is:
.eg
  .toc      = <myword-toc minlevel=1 maxlevel=4>
  .toc-all  = <myword-toc>

  #.        = <h1 data-myword-toc>
  ##.       = <h2 data-myword-toc>
  ###.      = <h3 data-myword-toc>
  ####.     = <h4 data-myword-toc>
  #####.    = <h5 data-myword-toc>
  ######.   = <h6 data-myword-toc>
Using the `(.toc) label will generate a table of headings 1-4, while `(.toc-all) will generate a table of all the headings. A custom element class is required to actually generate the table of links to the respective headings:
.eg
  class MyWordTOC extends HTMLElement {
    constructor() {
      super();
      this._minlevel = 1;
      this._maxlevel = 6;
    } // constructor()
    connectedCallback() {
      var oldTOC = this.querySelector('.toc')
      if (oldTOC) // if .toc already there, remove then rebuild
        oldTOC.parentNode.removeChild(oldTOC)
      var level
      level = this.getAttribute('minlevel')
      this._minlevel = (level) ? level : this._minlevel
      level = this.getAttribute('maxlevel')
      this._maxlevel = (level) ? level : this._maxlevel
      var hselector = []
      for (var level = this._minlevel; level<= this._maxlevel; level++ ) {
        hselector.push('h' + level.toString() + '[data-myword-toc]')
      } // for
      var headers = document.querySelectorAll(hselector.join(', '))	// gets all selected heading elements
      var header, header_id, tocContent = [this.innerHTML, '<table class=toc>']	// generated table of contents
      for (var h = 0; h < headers.length; h++) {
        header = headers[ h ]
        header_id = header.id
        if (!header_id) {	// if heading doesn't have an id, generate one based on content
          header_id = 'toc' + header.textContent.trim().replace(/[^\w$-@.&!*(),]/g, '_')
          header.id = header_id
        }
        tocContent.push('<tr><td><a href="#', header_id, '">', header.innerHTML, '</a></td></tr>\n')
      } // for
      tocContent.push('</table>')
      this.innerHTML = tocContent.join('')
    } // connectedCallback()
  } // MyWordTOC
  
  customElements.define('myword-toc', MyWordTOC)
The custom class `(MyWordTOC) will generate an innerHTML content consisting of the current `(myword-toc) content followed by a `(<table class=toc>) whose rows consist of links to the corresponding heading. The table of contents for this document:
.demo
  .toc  :b(Table of Contents)
A package implementing this simple TOC feature is found in `(pkgs/toc.mmk); a listing can be found in Appendix B.
###.  Example 3: A Live "Demo"
The `(.demo) markup used in this document displays MyWord content on the left side and the rendered HTML on the right. Let us now add the capability to edit the MyWord content and have rendered content immediately reflect the changes. To do this requires two new custom elements; one to support live editing, and one to monitor another element for changes which then can be reflected in its own content.

Editable content is commonly supported in modern browsers using the `(contentEditable) attribute. The only complication for a live `(.demo) is that we need to override the default behaviour for certain keys, e.g., `(tab). A custom `(myword-editable) element that implements this:
.eg
  class MyWordEditable extends HTMLElement {
    constructor() { super(); } 
    connectedCallback() {
      this.contentEditable = true //; console.log('contentEditable=',this.contentEditable)
      this.addEventListener('keydown', function (event) { // replace tab functionality
        if (event.keyCode == 9 || event.which == 9) {
          document.execCommand('insertText', false, '\t')
          event.preventDefault()
        } else event.stopPropagation()
        return false    // don't lose focus
      })
    } // connectedCallback()
  } // MyWordEditable

  if (!customElements.get('myword-editable'))
   Â customElements.define('myword-editable', MyWordEditable)
The second custom element named `(myword-sink) observes the content of another element, the source. When a change in the source content is detected, the new contents are transformed and the result replaces the current `(myword-sink) contents. A `(myword-sink) element has two defining attributes: the `(data-source), whose value is a CSS selector used to find the closest neighbour matching that selector, and the `(data-transform), whose value is the name of the transform to apply to the contents of the source. Here are the label and transform defintions for the current `(.demo) markup, and an extended version which allows editing source content will be reflected in the rendered HTML:
.eg
	.demo   = demo <table class='demo'>

	demo    :: (content) => 
		["<tr>",
		 "<td class='A1'>", markit('text',content), "</td>",
		 "<td class='B1'>", markit('myword',content), "</td>"
		 "</tr>"].join('')

	.demo? = demoE <table class='demo'>

	demoE  :: (content) => 
		["<tr>",
		 "<td class='A1'>",
		   "<myword-editable>", markit('text', content), "</myword-editable>",
		 "</td>",
		 "<td class='B1'>",
		   "<myword-sink data-source='.A1' data-transform=myword>", markit('myword', content), "</myword-sink>",
		 "</td>",
		 "</tr>"].join('')
The `(demoE) transform used for the live demo has an editable source element (`(td.A1)) and a sink element (`(td.B1)) which monitors it's closest neighbour (a direct descendant or ancestor's descendant) matching the selector `(.A1). When a change is observed the sink's contents are replaced by the result of applying the `(myword) transform to the modified source contents. Before looking at the code for the custom sink element, here's an example:
.demo?  Edit MyWord source here! 
The MyWordSink custom element uses a MutationObserver to monitor changes in the source element, and the global function `(x-markup.translateElement(_transform, _element)) provided by `(x-markup.js) to call the specified transform. This function replaces the text content of any element (in this case the sink element) by its transformation using the specified transform.
.eg
  class MyWordSink extends HTMLElement {
    constructor() { super(); }
    connectedCallback() {
      var sourceSelector = this.getAttribute('data-source')
      var transform = this.getAttribute('data-transform')
        if (sourceSelector) {
          var source = findClosest(this, sourceSelector.trim())
          if (source) {
            var sourceObserver = new MutationObserver(function(mutations, observer) {
            if (observer.transform) {
              observer.sink.textContent = observer.source.innerText || observer.source.textContent
              window.x_markup.transformElement(observer.transform, observer.sink)  // x-markup API function 
            } else {
              observer.sink.textContent = observer.source.innerHTML // no transform, display raw HTML as text
            }
          })
          sourceObserver.source = source
          sourceObserver.sink = this
          sourceObserver.transform = transform ? transform.trim() : null
          sourceObserver.observe(source, {subtree: true, childList:true, characterData: true})
        } else {
          this.innerHTML = errorString("No source found in &lt;myword-sink> using selector " + sourceSelector)
        }
      }
    }
  }
  if (!customElements.get('myword-sink'))
    customElements.define('myword-sink', MyWordSink)

  // Helper functions :

  function findClosest(parentElem, selector) {
    // find the closest relative matching selector
    var closest = null
    if (parentElem) {
      closest = parentElem.querySelector(selector)
      if (!closest) closest = findClosest(parentElem.parentElement, selector)
    }
    return closest
  } // findClosest(parentElem, selector)

  function errorString(errorInfo) {
    console.error(errorInfo)
    return ["<pre><mark style='color:blue'>\n*** Error *** ", errorInfo, "\n</mark></pre>"].join('');
  }
To add a collapsible display of the HTML representation of the rendered content, a second row is added to the table. The right handle element is the HTML and the left hand element is a button to toggle the display:
.demo?+  Editable demo with optional HTML...
The `(metamark) definitions for this extended feature:
.eg
  .demo?+	= demoEH <table class='demo'>

  demoEH	:: (content) => {
      var html = markit('myword', content);
      return ["<tr>",
              "<td class='A1'>",
                "<myword-editable>", markit('text', content), "</myword-editable>",
              "</td>",
              "<td class='B1'>",
                "<myword-sink data-source='.A1' data-transform=myword>", html, "</myword-sink>",
              "</td>",
              "</tr>",
              "<tr>",
                "<td style='vertical-align:top'>",
		  "<button onclick='var toHide = this.parentNode.nextSibling; toHide.hidden = !toHide.hidden'>Toggle HTML Display</button>",
                "</td>",
                "<td class='A3' hidden>",
                  "<myword-sink data-source='.B1>myword-sink'>", markit('text', html), "</myword-sink>",
                "</td>",
                "</tr>"].join('')
      }
A package implementing the extended demo package is found in `(pkgs/demoEdit.mmk); a listing can be found in Appendix C.
###.  Support for Custom Elements
Custom elements are a part of the HTML5 Web Components standard and are supported to various degrees in current browsers. Until ubiquitous support is available, a polyfill for custom elements can be found at @cePolyfill(webcomponentsjs).
###.  Summary
It is a fairly straight process to define MyWord labels which generate custom element tags, and then write JavaScript code in `(metamark) packages to provide semantics for those elements. In this way document level features can implemented that can't be easily done in a context insensitive translator like MyWord.
&  .mmk = <pre> text
   @import pkgs/toc.mmk pkgs/demoEdit.mmk
   @intro = <a href='https://ridgeworks.github.io/MyWord/MyWord.html'>
   @custom = <a href='https://www.w3.org/TR/custom-elements/'>
   @lingo = <a href='https://ridgeworks.github.io/MyWord/MyWordLingo.html'>
   @cePolyfill = <a href='https://github.com/webcomponents/custom-elements'>

###.(Appendix A: `(defines.mmk)) 
@include  pkgs/defines.mmk
###.(Appendix B: `(toc.mmk)) 
@include  pkgs/toc.mmk
###.(Appendix C: `(demoEdit.mmk)) 
@include  pkgs/demoEdit.mmk

